<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[]]></title>
  <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/atom.xml" rel="self"/>
  <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/"/>
  <updated>2018-02-24T15:15:16+08:00</updated>
  <id>https://github.com/HearOtSea/HearOtSea.github.io.git/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[2018-02-23-内购]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15193489395143.html"/>
    <updated>2018-02-23T09:22:19+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15193489395143.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;内购&quot;<br/>
date: 2018.02.23</p>

<h2 id="toc_0">tag: iOS 总结</h2>

<h2 id="toc_1">1. 导入 <StoreKit/StoreKit.h></h2>

<h2 id="toc_2">2. 遵循 SKProductsRequestDelegate, SKPaymentTransactionObserver 协议</h2>

<h2 id="toc_3">3. 设置商品 ID</h2>

<pre><code>//在内购项目中创的商品单号
#define ProductID_IAP0p20 @&quot;Nada.JPYF01&quot;//20
#define ProductID_IAP1p100 @&quot;Nada.JPYF02&quot; //100
#define ProductID_IAP4p600 @&quot;Nada.JPYF03&quot; //600
#define ProductID_IAP9p1000 @&quot;Nada.JPYF04&quot; //1000
#define ProductID_IAP24p6000 @&quot;Nada.JPYF05&quot; //6000
</code></pre>

<h2 id="toc_4">添加观察者</h2>

<pre><code>-(void)viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];
    // 添加观察者
    [[SKPaymentQueue defaultQueue] addTransactionObserver:self];
}
</code></pre>

<h2 id="toc_5">移除观察者</h2>

<pre><code>-(void)viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];
    // 移除观察者
    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];
}
</code></pre>

<h2 id="toc_6">设置 UI</h2>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    self.title = @&quot;内购&quot;;

//    self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;测试&quot; style:UIBarButtonItemStylePlain target:self action:@selector(test)];

    // 恢复购买的按钮
    UIButton * revert = [[UIButton alloc]initWithFrame:CGRectMake(20, 100, 100, 80)];
    [revert setBackgroundColor:[UIColor cyanColor]];
    [revert addTarget:self action:@selector(test) forControlEvents:UIControlEventTouchUpInside];
    [revert setTitle:@&quot;pay&quot; forState:UIControlStateNormal];
    [self.view addSubview: revert];
    self.view.backgroundColor = [UIColor whiteColor];
}
</code></pre>

<h2 id="toc_7">测试内购</h2>

<pre><code>-(void)test{

    if([SKPaymentQueue canMakePayments]){

        // productID就是你在创建购买项目时所填写的产品ID
        selectProductID = [NSString stringWithFormat:@&quot;%@&quot;,ProductID1];
        [self requestProductID:selectProductID];

    }else{

        // NSLog(@&quot;不允许程序内付费&quot;);
        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;温馨提议&quot; message:@&quot;请先开启应用内付费购买功能。&quot; preferredStyle:UIAlertControllerStyleAlert];
        [alertController addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:nil]];
        [self presentViewController:alertController animated:YES completion:nil];

    }
}
</code></pre>

<h2 id="toc_8">请求所有的商品 ID</h2>

<pre><code>#pragma mark 1.请求所有的商品ID
-(void)requestProductID:(NSString *)productID{

    // 1.拿到所有可卖商品的ID数组
    NSArray *productIDArray = [[NSArray alloc]initWithObjects:productID, nil];
    NSSet *sets = [[NSSet alloc]initWithArray:productIDArray];

    // 2.向苹果发送请求，请求所有可买的商品
    // 2.1.创建请求对象
    SKProductsRequest *sKProductsRequest = [[SKProductsRequest alloc]initWithProductIdentifiers:sets];
    // 2.2.设置代理(在代理方法里面获取所有的可卖的商品)
    sKProductsRequest.delegate = self;
    // 2.3.开始请求
    [sKProductsRequest start];

}
</code></pre>

<h2 id="toc_9">苹果那边的内购监听</h2>

<pre><code>#pragma mark 2.苹果那边的内购监听
-(void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response{

    NSLog(@&quot;可卖商品的数量=%ld&quot;,response.products.count);

    NSArray *product = response.products;
    if([product count] == 0){

        NSLog(@&quot;没有商品&quot;);
        return;
    }

    for (SKProduct *sKProduct in product) {

        NSLog(@&quot;pro info&quot;);
        NSLog(@&quot;SKProduct 描述信息：%@&quot;, sKProduct.description);
        NSLog(@&quot;localizedTitle 产品标题：%@&quot;, sKProduct.localizedTitle);
        NSLog(@&quot;localizedDescription 产品描述信息：%@&quot;,sKProduct.localizedDescription);
        NSLog(@&quot;price 价格：%@&quot;,sKProduct.price);
        NSLog(@&quot;productIdentifier Product id：%@&quot;,sKProduct.productIdentifier);

        if([sKProduct.productIdentifier isEqualToString: selectProductID]){

            [self buyProduct:sKProduct];

            break;

        }else{

            //NSLog(@&quot;不不不相同&quot;);
        }
    }

}
</code></pre>

<h2 id="toc_10">内购代码调用</h2>

<pre><code>#pragma mark 内购的代码调用
-(void)buyProduct:(SKProduct *)product{

    // 1.创建票据
    SKPayment *skpayment = [SKPayment paymentWithProduct:product];

    // 2.将票据加入到交易队列
    [[SKPaymentQueue defaultQueue] addPayment:skpayment];

    // 3.添加观察者，监听用户是否付钱成功(不在此处添加观察者)
    //[[SKPaymentQueue defaultQueue] addTransactionObserver:self];

}
</code></pre>

<h2 id="toc_11">实现观察者监听付钱的代理方法，只要交易发生变化就会走下面的方法</h2>

<pre><code>#pragma mark 4.实现观察者监听付钱的代理方法,只要交易发生变化就会走下面的方法
-(void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions{

    /*
     SKPaymentTransactionStatePurchasing,    正在购买
     SKPaymentTransactionStatePurchased,     已经购买
     SKPaymentTransactionStateFailed,        购买失败
     SKPaymentTransactionStateRestored,      回复购买中
     SKPaymentTransactionStateDeferred       交易还在队列里面，但最终状态还没有决定
     */

    for (SKPaymentTransaction *transaction in transactions) {
        switch (transaction.transactionState) {
            case SKPaymentTransactionStatePurchasing:{

                NSLog(@&quot;正在购买&quot;);
            }break;
            case SKPaymentTransactionStatePurchased:{

                NSLog(@&quot;购买成功&quot;);
                // 购买后告诉交易队列，把这个成功的交易移除掉
                [queue finishTransaction:transaction];
                [self buyAppleStoreProductSucceedWithPaymentTransactionp:transaction];
            }break;
            case SKPaymentTransactionStateFailed:{

                NSLog(@&quot;购买失败&quot;);
                // 购买失败也要把这个交易移除掉
                [queue finishTransaction:transaction];
            }break;
            case SKPaymentTransactionStateRestored:{
                NSLog(@&quot;回复购买中,也叫做已经购买&quot;);
                // 回复购买中也要把这个交易移除掉
                [queue finishTransaction:transaction];
            }break;
            case SKPaymentTransactionStateDeferred:{

                NSLog(@&quot;交易还在队列里面，但最终状态还没有决定&quot;);
            }break;
            default:
                break;
        }
    }
}
</code></pre>

<h2 id="toc_12">苹果内购支付成功</h2>

<pre><code>// 苹果内购支付成功
- (void)buyAppleStoreProductSucceedWithPaymentTransactionp:(SKPaymentTransaction *)paymentTransactionp {

    NSString * productIdentifier = paymentTransactionp.payment.productIdentifier;
    // NSLog(@&quot;productIdentifier Product id：%@&quot;, productIdentifier);
    NSString *transactionReceiptString= nil;

    //系统IOS7.0以上获取支付验证凭证的方式应该改变，切验证返回的数据结构也不一样了。
    NSString *version = [UIDevice currentDevice].systemVersion;
    if([version intValue] &gt;= 7.0){
        // 验证凭据，获取到苹果返回的交易凭据
        // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址
        NSURLRequest * appstoreRequest = [NSURLRequest requestWithURL:[[NSBundle mainBundle]appStoreReceiptURL]];
        NSError *error = nil;
//        [NSURLSession dataTaskWithRequest:appstoreRequest completionHandler:nil]
        NSData * receiptData = [NSURLConnection sendSynchronousRequest:appstoreRequest returningResponse:nil error:&amp;error];
        transactionReceiptString = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
    }else{

        NSData * receiptData = paymentTransactionp.transactionReceipt;
        //  transactionReceiptString = [receiptData base64EncodedString];
        transactionReceiptString = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
    }
    // 去验证是否真正的支付成功了
    [self checkAppStorePayResultWithBase64String:transactionReceiptString];

}
</code></pre>

<h2 id="toc_13">生成订单参数</h2>

<pre><code>- (void)checkAppStorePayResultWithBase64String:(NSString *)base64String {

    /* 生成订单参数，注意沙盒测试账号与线上正式苹果账号的验证途径不一样，要给后台标明 */
    /*
     注意：
     自己测试的时候使用的是沙盒购买(测试环境)
     App Store审核的时候也使用的是沙盒购买(测试环境)
     上线以后就不是用的沙盒购买了(正式环境)
     所以此时应该先验证正式环境，在验证测试环境

     正式环境验证成功，说明是线上用户在使用
     正式环境验证不成功返回21007，说明是自己测试或者审核人员在测试
     */
    /*
     苹果AppStore线上的购买凭证地址是： https://buy.itunes.apple.com/verifyReceipt
     测试地址是：https://sandbox.itunes.apple.com/verifyReceipt
     */
    //    NSNumber *sandbox;
    NSString *sandbox;
#if (defined(APPSTORE_ASK_TO_BUY_IN_SANDBOX) &amp;&amp; defined(DEBUG))
    //sandbox = @(0);
    sandbox = @&quot;0&quot;;
#else
    //sandbox = @(1);
    sandbox = @&quot;1&quot;;
#endif

    NSMutableDictionary *prgam = [[NSMutableDictionary alloc] init];;
    [prgam setValue:sandbox forKey:@&quot;sandbox&quot;];
    [prgam setValue:base64String forKey:@&quot;reciept&quot;];

    /*
     请求后台接口，服务器处验证是否支付成功，依据返回结果做相应逻辑处理
     0 代表沙盒  1代表 正式的内购
     最后最验证后的
     */
    /*
     内购验证凭据返回结果状态码说明
     21000 App Store无法读取你提供的JSON数据
     21002 收据数据不符合格式
     21003 收据无法被验证
     21004 你提供的共享密钥和账户的共享密钥不一致
     21005 收据服务器当前不可用
     21006 收据是有效的，但订阅服务已经过期。当收到这个信息时，解码后的收据信息也包含在返回内容中
     21007 收据信息是测试用（sandbox），但却被发送到产品环境中验证
     21008 收据信息是产品环境中使用，但却被发送到测试环境中验证
     */

    NSLog(@&quot;字典==%@&quot;,prgam);

}
</code></pre>

<h2 id="toc_14">客户端验证购买凭据</h2>

<pre><code>#pragma mark 客户端验证购买凭据
- (void)verifyTransactionResult
{
    // 验证凭据，获取到苹果返回的交易凭据
    // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址
    NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];
    // 从沙盒中获取到购买凭据
    NSData *receipt = [NSData dataWithContentsOfURL:receiptURL];
    // 传输的是BASE64编码的字符串
    /**
     BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性
     BASE64是可以编码和解码的
     */
    NSDictionary *requestContents = @{
                                      @&quot;receipt-data&quot;: [receipt base64EncodedStringWithOptions:0]
                                      };
    NSError *error;
    // 转换为 JSON 格式
    NSData *requestData = [NSJSONSerialization dataWithJSONObject:requestContents
                                                          options:0
                                                            error:&amp;error];
    // 不存在
    if (!requestData) { /* ... Handle error ... */ }

    // 发送网络POST请求，对购买凭据进行验证
    NSString *verifyUrlString;
#if (defined(APPSTORE_ASK_TO_BUY_IN_SANDBOX) &amp;&amp; defined(DEBUG))
    verifyUrlString = @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;;
#else
    verifyUrlString = @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;;
#endif
    // 国内访问苹果服务器比较慢，timeoutInterval 需要长一点
    NSMutableURLRequest *storeRequest = [NSMutableURLRequest requestWithURL:[[NSURL alloc] initWithString:verifyUrlString] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f];

    [storeRequest setHTTPMethod:@&quot;POST&quot;];
    [storeRequest setHTTPBody:requestData];

    // 在后台对列中提交验证请求，并获得官方的验证JSON结果
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [NSURLConnection sendAsynchronousRequest:storeRequest queue:queue
                           completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
                               if (connectionError) {
                                   NSLog(@&quot;链接失败&quot;);
                               } else {
                                   NSError *error;
                                   NSDictionary *jsonResponse = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error];
                                   if (!jsonResponse) {
                                       NSLog(@&quot;验证失败&quot;);
                                   }

                                   // 比对 jsonResponse 中以下信息基本上可以保证数据安全
                                   /*
                                    bundle_id
                                    application_version
                                    product_id
                                    transaction_id
                                    */

                                   NSLog(@&quot;验证成功&quot;);
                               }
                           }];

}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-12-狗年吉祥]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15184172518005.html"/>
    <updated>2018-02-12T14:34:11+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15184172518005.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;狗年吉祥&quot;<br/>
date: 2018.02.12</p>

<h2 id="toc_0">tag: 生活总结</h2>

<h2 id="toc_1">最近身体情况</h2>

<ul>
<li><p>近来身体很虚，可能是和前几天的熬夜有关，太累健身我觉得会起反作用所以停了</p></li>
<li><p>以下的意见是在知乎上看到的：</p></li>
</ul>

<pre><code># 1. 你是胖子请减肥，你是瘦子请健身并增肥，匀称健康的肉体穿衣服更好看。

# 2. 注意穿衣搭配，毕竟人靠衣装马靠鞍。

# 3. 保养皮肤，肤色不重要，当然白皙最好，但是一定不能长痘，不能有粗大毛孔。

# 4. 发型很重要，根据脸型选发型。

# 5. 细节处理，比如指甲、胡须、眉毛、鼻毛、脚毛等等。

# 6. 读书，大家都喜欢有文化有涵养的人
</code></pre>

<h2 id="toc_2">最近的工作情况</h2>

<ul>
<li><p>年关将近根本无心工作，满脑子只有 [ 啊~ 终于过年了 这个年好想也并不好过啊 咋整 ]</p></li>
<li><p>回家将面临着 [ 考虑啥时候谈对象结婚巴拉巴拉 ] 之类的询问，想想就头大</p></li>
<li><p>已经做好了开年来高强度压力工作量的心理准备，who 怕 who 啊</p></li>
</ul>

<h2 id="toc_3">博客通知</h2>

<ul>
<li><p>今天过后，可能会一阵子不更新博客，因为要过年啦~</p></li>
<li><p>不管离家多远能否回家过年，都希望看到这篇博客的人幸福安康，阖家欢乐~</p></li>
<li><p>好啦，那就不多 BB 了，心海在这里跟看这篇博客的人提前拜个早年了~</p></li>
<li><p>祝大家狗年在狗年里，像神犬一样头脑聪明、行动机灵、体态轻盈。</p></li>
<li><p>大家，新年好 ~</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-12-项目中会用到的知识]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15184166364607.html"/>
    <updated>2018-02-12T14:23:56+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15184166364607.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;项目中会用到的知识&quot;<br/>
date: 2018.02.12</p>

<h2 id="toc_0">tag: iOS 总结</h2>

<h1 id="toc_1">本文转自简书，仅供学习</h1>

<h2 id="toc_2">【百度】（二面挂）</h2>

<h3 id="toc_3">一面：</h3>

<ul>
<li><p>1.说下线程和进程的区别</p></li>
<li><p>2.如何保证线程安全</p></li>
<li><p>3.写个算法，输出2~100的素数（然后问你怎么优化，还可以怎么优化，然后还可以怎样优化.....）</p></li>
<li><p>4.了解哪些设计模式</p></li>
<li><p>5.MVC设计模式的思想是什么？在项目中的运用，然后对比MVVM设计模式</p></li>
<li><p>6.堆和栈的区别，工程项目中的哪些数据是储存在堆哪些在栈中</p></li>
<li><p>7.iOS中的NSCopying协议，copy,MutableCopy的区别</p></li>
<li><p>8.解释属性修饰关键词的作用（weak,strong,copy,readOnly,assgin,nonatomic等）</p></li>
<li><p>9.最近看过哪些书？目录结构是怎样的？哪部分内容印象最深？了解过作者吗？</p></li>
<li><p>10.你还有什么问题问我？</p></li>
</ul>

<span id="more"></span><!-- more -->

<h3 id="toc_4">二面：</h3>

<ul>
<li><p>1.写二叉树的先序遍历，然后用非递归写</p></li>
<li><p>2.写快排，并分析原理</p></li>
<li><p>3.http协议</p></li>
<li><p>4.http为什么底层是tcp不是udp ?</p></li>
<li><p>5.tcp是基于流式传输的，怎么设计协议，进行协议的解析？</p></li>
<li><p>6.tcp为什么要进行三次握手？不是2次，4次？</p></li>
<li><p>7.抓包工具的原理是啥？</p></li>
<li><p>8.socket异常断开时，设计一个合理的重连机制。</p></li>
<li><p>9.内存管理</p></li>
<li><p>10.iOS开发中用过哪些测试性能的工具</p></li>
<li><p>11.instruments它为什么能检测内存泄漏</p></li>
<li><p>12.做过的项目有什么技术难点（我说的难点在面试官看来都不是难点）？</p></li>
<li><p>13.在10亿个数中如何快速找到最大的前100个数？</p></li>
<li><p>14.你有什么创新能力？</p></li>
<li><p>15.你还有什么问题问我？</p></li>
</ul>

<p>总结：偏向基础，问题逐步深入。</p>

<h2 id="toc_5">【京东】（二面莫名其妙挂）</h2>

<h3 id="toc_6">一面：</h3>

<ul>
<li><p>1.解释属性修饰关键词的作用（weak,strong,copy,readOnly,assgin,nonatomic等）</p></li>
<li><p>2.项目中用过哪些设计模式</p></li>
<li><p>3.结合响应者链条和设计模式，解释事件怎样传递和处理</p></li>
<li><p>4.blcok，NSNotification，delegate，Observer比较</p></li>
<li><p>5.block为什么会导致循环引用</p></li>
<li><p>6.为什么想来京东</p></li>
<li><p>7.聊人生</p></li>
</ul>

<h3 id="toc_7">二面：</h3>

<ul>
<li><p>（项目：因为实习的公司用的SDK组件化的开发模式，拿出来作品一边演示他一边提问，1-6点都是对于我的SDK项目提问）</p></li>
<li><p>1.为什么需要组件化？</p></li>
<li><p>2.tableView的性能优化</p></li>
<li><p>3.SDK的接口设计过程（一般设计为进入业务线提供一个注册方法，在需要的时候使用代理回调。向SDK里传递数据一般用单利模式，开出相应的方法）</p></li>
<li><p>4.cocoaPods的实现思路，为什么没有使用cocoaPods管理自己的SDK</p></li>
<li><p>5.项目中缓存SDK采用的策略（我们项目主要借鉴了YYCache，采用lru算法，使用sqlite）</p></li>
<li><p>6.相对复杂业务交互的处理，采用的设计模式（单利模式配合模板方法模式实现）</p></li>
<li><p>7.AFN实现思路，对源码的理解程度</p></li>
<li><p>8.项目中如何保证数据的安全性</p></li>
<li><p>9.runtime在奇葩需求当中的运用（比如产品要求5和6上面显示不同的字体大小，可以用runtime的交换方法）</p></li>
<li><p>9.快排的原理</p></li>
<li><p>10.C语言中strlen和sizeof的区别</p></li>
<li><p>11.职业规划（开始聊人生）</p></li>
<li><p>总结：偏向项目，主要考察对业务的处理熟练度。（这是我最拿手的，二面差不多聊了1个多小时，没有答不上来问题，走的时候我跟面试官都很开心，晚上回去一看官网状态为未通过，伤心极了）</p></li>
</ul>

<h2 id="toc_8">【同花顺】</h2>

<h3 id="toc_9">一面：（问的太基础）</h3>

<ul>
<li><p>1.对于面向对象的理解</p></li>
<li><p>2.内存管理</p></li>
<li><p>3.多线程</p></li>
<li><p>4.保证线程安全的方式（加锁和GCD栅栏，队列组相关知识）</p></li>
<li><p>5.KVC和KVO的使用和注意事项</p></li>
<li><p>6.推送的原理</p></li>
<li><p>7.tableViewCell的自适应如何实现，如何保证性能</p></li>
<li><p>8.堆和栈的区别</p></li>
</ul>

<h3 id="toc_10">二面：</h3>

<ul>
<li><p>1.SDWebImage的底层实现（我只答到了没有沙盒的时如何实现）</p></li>
<li><p>2.简述下runLoop（问了应用程序在不同条件下各个线程runLoop所处模式）</p></li>
<li><p>3.一个页面可以由几个控制器共同管理吗</p></li>
<li><p>4.http和socket的区别</p></li>
<li><p>5.什么时候用集合(NSSet)</p></li>
<li><p>6.项目上线或者版本迭代，有过被拒吗？是什么原因？怎么解决？</p></li>
<li><p>7.转场动画相关操作</p></li>
<li><p>8.绘图相关知识(coreGraphics框架的使用)</p></li>
<li><p>9.数据持久化</p></li>
<li><p>10.xib和代码适配界面有什么不一样</p></li>
<li><p>11.项目中遇到的问题，如何解决（我从所做的项目的框架搭建，模块分布，设计类图，开发，自测，上线一直扯）</p></li>
<li><p>12.最早什么时候能够来实习（感觉他们很缺人，但是我问了下他们部门都有30多个iOS开发者！！）</p></li>
</ul>

<h3 id="toc_11">三面：（因为薪资没谈拢加了一次技术面）</h3>

<ul>
<li><p>1.assgin和weak的区别，代理为什么用assgin</p></li>
<li><p>2.类方法：load 和 initialize 有什么区别，一般怎么用它们</p></li>
<li><p>3.OC语言的动态机制的理解（开始浅谈runtime）</p></li>
<li><p>4.设计模式：代理和观察者模式的对比，单利模式的使用注意点</p></li>
<li><p>5.如何设计网络请求框架（我按照AFN的理解去解释了一波）</p></li>
<li><p>6.响应者链条</p></li>
<li><p>7.iPhone自带的AssistiveTouch你如何实现</p></li>
<li><p>8.App包的大小受哪些影响</p></li>
<li><p>9.关于debug和release</p></li>
<li><p>10.view的生命周期</p></li>
</ul>

<h3 id="toc_12">四面：</h3>

<ul>
<li><p>（HR面，基本上是闲扯，想着反正拿到offer也不得去，我问他的问题都比他问我的还要多。。。基本上也记不住了）</p></li>
<li><p>1.说出你的三个缺点和优点</p></li>
<li><p>2.为什么选择同花顺</p></li>
<li><p>3.说出你在大学期间干过的最牛逼的一件事</p></li>
<li><p>4.对于我们企业文化的理解（我把我实习公司的企业文化吹嘘了一遍，发现这几点基本上放在任何私企都好使：客户至上，团队合作，诚信正直，务实创新）</p></li>
<li><p>总结：技术面非常偏向项目，感觉前面两个面试官比较水。</p></li>
</ul>

<h5 id="toc_13">综上所述：秋招的一线互联网公司基本上看中学习能力和刻苦勤奋程度。比如百词斩给出的招聘要求就是精通数据结构和算法，没有实际开发经验的都可以。所以要想去大厂基础是必不可少的，而且必须深入学习。</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-12-项目中会用到的知识]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15179689057067.html"/>
    <updated>2018-02-07T10:01:45+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15179689057067.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;项目中会用到的知识&quot;<br/>
date: 2018.02.07</p>

<h2 id="toc_0">tag: iOS 面试题</h2>

<h1 id="toc_1">本文转自简书，仅供学习</h1>

<h2 id="toc_2">【百度】（二面挂）</h2>

<h3 id="toc_3">一面：</h3>

<ul>
<li><p>1.说下线程和进程的区别</p></li>
<li><p>2.如何保证线程安全</p></li>
<li><p>3.写个算法，输出2~100的素数（然后问你怎么优化，还可以怎么优化，然后还可以怎样优化.....）</p></li>
<li><p>4.了解哪些设计模式</p></li>
<li><p>5.MVC设计模式的思想是什么？在项目中的运用，然后对比MVVM设计模式</p></li>
<li><p>6.堆和栈的区别，工程项目中的哪些数据是储存在堆哪些在栈中</p></li>
<li><p>7.iOS中的NSCopying协议，copy,MutableCopy的区别</p></li>
<li><p>8.解释属性修饰关键词的作用（weak,strong,copy,readOnly,assgin,nonatomic等）</p></li>
<li><p>9.最近看过哪些书？目录结构是怎样的？哪部分内容印象最深？了解过作者吗？</p></li>
<li><p>10.你还有什么问题问我？</p></li>
</ul>

<span id="more"></span><!-- more -->

<h3 id="toc_4">二面：</h3>

<ul>
<li><p>1.写二叉树的先序遍历，然后用非递归写</p></li>
<li><p>2.写快排，并分析原理</p></li>
<li><p>3.http协议</p></li>
<li><p>4.http为什么底层是tcp不是udp ?</p></li>
<li><p>5.tcp是基于流式传输的，怎么设计协议，进行协议的解析？</p></li>
<li><p>6.tcp为什么要进行三次握手？不是2次，4次？</p></li>
<li><p>7.抓包工具的原理是啥？</p></li>
<li><p>8.socket异常断开时，设计一个合理的重连机制。</p></li>
<li><p>9.内存管理</p></li>
<li><p>10.iOS开发中用过哪些测试性能的工具</p></li>
<li><p>11.instruments它为什么能检测内存泄漏</p></li>
<li><p>12.做过的项目有什么技术难点（我说的难点在面试官看来都不是难点）？</p></li>
<li><p>13.在10亿个数中如何快速找到最大的前100个数？</p></li>
<li><p>14.你有什么创新能力？</p></li>
<li><p>15.你还有什么问题问我？</p></li>
</ul>

<p>总结：偏向基础，问题逐步深入。</p>

<h2 id="toc_5">【京东】（二面莫名其妙挂）</h2>

<h3 id="toc_6">一面：</h3>

<ul>
<li><p>1.解释属性修饰关键词的作用（weak,strong,copy,readOnly,assgin,nonatomic等）</p></li>
<li><p>2.项目中用过哪些设计模式</p></li>
<li><p>3.结合响应者链条和设计模式，解释事件怎样传递和处理</p></li>
<li><p>4.blcok，NSNotification，delegate，Observer比较</p></li>
<li><p>5.block为什么会导致循环引用</p></li>
<li><p>6.为什么想来京东</p></li>
<li><p>7.聊人生</p></li>
</ul>

<h3 id="toc_7">二面：</h3>

<ul>
<li><p>（项目：因为实习的公司用的SDK组件化的开发模式，拿出来作品一边演示他一边提问，1-6点都是对于我的SDK项目提问）</p></li>
<li><p>1.为什么需要组件化？</p></li>
<li><p>2.tableView的性能优化</p></li>
<li><p>3.SDK的接口设计过程（一般设计为进入业务线提供一个注册方法，在需要的时候使用代理回调。向SDK里传递数据一般用单利模式，开出相应的方法）</p></li>
<li><p>4.cocoaPods的实现思路，为什么没有使用cocoaPods管理自己的SDK</p></li>
<li><p>5.项目中缓存SDK采用的策略（我们项目主要借鉴了YYCache，采用lru算法，使用sqlite）</p></li>
<li><p>6.相对复杂业务交互的处理，采用的设计模式（单利模式配合模板方法模式实现）</p></li>
<li><p>7.AFN实现思路，对源码的理解程度</p></li>
<li><p>8.项目中如何保证数据的安全性</p></li>
<li><p>9.runtime在奇葩需求当中的运用（比如产品要求5和6上面显示不同的字体大小，可以用runtime的交换方法）</p></li>
<li><p>9.快排的原理</p></li>
<li><p>10.C语言中strlen和sizeof的区别</p></li>
<li><p>11.职业规划（开始聊人生）</p></li>
<li><p>总结：偏向项目，主要考察对业务的处理熟练度。（这是我最拿手的，二面差不多聊了1个多小时，没有答不上来问题，走的时候我跟面试官都很开心，晚上回去一看官网状态为未通过，伤心极了）</p></li>
</ul>

<h2 id="toc_8">【同花顺】</h2>

<h3 id="toc_9">一面：（问的太基础）</h3>

<ul>
<li><p>1.对于面向对象的理解</p></li>
<li><p>2.内存管理</p></li>
<li><p>3.多线程</p></li>
<li><p>4.保证线程安全的方式（加锁和GCD栅栏，队列组相关知识）</p></li>
<li><p>5.KVC和KVO的使用和注意事项</p></li>
<li><p>6.推送的原理</p></li>
<li><p>7.tableViewCell的自适应如何实现，如何保证性能</p></li>
<li><p>8.堆和栈的区别</p></li>
</ul>

<h3 id="toc_10">二面：</h3>

<ul>
<li><p>1.SDWebImage的底层实现（我只答到了没有沙盒的时如何实现）</p></li>
<li><p>2.简述下runLoop（问了应用程序在不同条件下各个线程runLoop所处模式）</p></li>
<li><p>3.一个页面可以由几个控制器共同管理吗</p></li>
<li><p>4.http和socket的区别</p></li>
<li><p>5.什么时候用集合(NSSet)</p></li>
<li><p>6.项目上线或者版本迭代，有过被拒吗？是什么原因？怎么解决？</p></li>
<li><p>7.转场动画相关操作</p></li>
<li><p>8.绘图相关知识(coreGraphics框架的使用)</p></li>
<li><p>9.数据持久化</p></li>
<li><p>10.xib和代码适配界面有什么不一样</p></li>
<li><p>11.项目中遇到的问题，如何解决（我从所做的项目的框架搭建，模块分布，设计类图，开发，自测，上线一直扯）</p></li>
<li><p>12.最早什么时候能够来实习（感觉他们很缺人，但是我问了下他们部门都有30多个iOS开发者！！）</p></li>
</ul>

<h3 id="toc_11">三面：（因为薪资没谈拢加了一次技术面）</h3>

<ul>
<li><p>1.assgin和weak的区别，代理为什么用assgin</p></li>
<li><p>2.类方法：load 和 initialize 有什么区别，一般怎么用它们</p></li>
<li><p>3.OC语言的动态机制的理解（开始浅谈runtime）</p></li>
<li><p>4.设计模式：代理和观察者模式的对比，单利模式的使用注意点</p></li>
<li><p>5.如何设计网络请求框架（我按照AFN的理解去解释了一波）</p></li>
<li><p>6.响应者链条</p></li>
<li><p>7.iPhone自带的AssistiveTouch你如何实现</p></li>
<li><p>8.App包的大小受哪些影响</p></li>
<li><p>9.关于debug和release</p></li>
<li><p>10.view的生命周期</p></li>
</ul>

<h3 id="toc_12">四面：</h3>

<ul>
<li><p>（HR面，基本上是闲扯，想着反正拿到offer也不得去，我问他的问题都比他问我的还要多。。。基本上也记不住了）</p></li>
<li><p>1.说出你的三个缺点和优点</p></li>
<li><p>2.为什么选择同花顺</p></li>
<li><p>3.说出你在大学期间干过的最牛逼的一件事</p></li>
<li><p>4.对于我们企业文化的理解（我把我实习公司的企业文化吹嘘了一遍，发现这几点基本上放在任何私企都好使：客户至上，团队合作，诚信正直，务实创新）</p></li>
<li><p>总结：技术面非常偏向项目，感觉前面两个面试官比较水。</p></li>
</ul>

<h5 id="toc_13">综上所述：秋招的一线互联网公司基本上看中学习能力和刻苦勤奋程度。比如百词斩给出的招聘要求就是精通数据结构和算法，没有实际开发经验的都可以。所以要想去大厂基础是必不可少的，而且必须深入学习。</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-09-C 语言总结]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15181600421700.html"/>
    <updated>2018-02-09T15:07:22+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15181600421700.html</id>
    <content type="html"><![CDATA[
<!-- ---
layout: post
title: "One"
date: 2018.02.09
tag: C 总结

----->

<ul>
<li>
<a href="#toc_0">第一个 C 程序</a>
<ul>
<li>
<a href="#toc_1">创建项目</a>
</li>
<li>
<a href="#toc_2">代码</a>
</li>
<li>
<a href="#toc_3">整个项目的细节</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">练习</a>
<ul>
<li>
<a href="#toc_5">项目的执行流程</a>
</li>
<li>
<a href="#toc_6">创建多个项目</a>
</li>
<li>
<a href="#toc_7">代码</a>
</li>
<li>
<a href="#toc_8">运行其它的项目</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">开发中应该注意的地方</a>
<ul>
<li>
<a href="#toc_10">注意点</a>
</li>
<li>
<a href="#toc_11">关键字</a>
</li>
<li>
<a href="#toc_12">标识符</a>
</li>
<li>
<a href="#toc_13">标识符的命名规范 (可以遵守可以不遵守)</a>
</li>
<li>
<a href="#toc_14">注释</a>
</li>
<li>
<a href="#toc_15">注释的注意点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_16">数据及数据类型</a>
<ul>
<li>
<a href="#toc_17">数据</a>
</li>
<li>
<a href="#toc_18">常量</a>
</li>
<li>
<a href="#toc_19">变量</a>
</li>
<li>
<a href="#toc_20">变量的初始化</a>
</li>
<li>
<a href="#toc_21">变量的作用域</a>
</li>
<li>
<a href="#toc_22">变量内存分析</a>
</li>
<li>
<a href="#toc_23">printf 输出</a>
</li>
<li>
<a href="#toc_24">scanf 输入 - 代码</a>
</li>
<li>
<a href="#toc_25">scanf函数的实现原理</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->

<h2 id="toc_0">第一个 C 程序</h2>

<h3 id="toc_1">创建项目</h3>

<pre><code>Product Name                    : 产品名称／项目名称       (baidu)    
Organization Name               : 组织机构名称／公司名称   (百度)    
Organization Identifier         : 组织机构标识，一般填公司逆向名称  (com.baidu)    
Bundle Identifier               : 产品唯一标识   (设计上线之后，钱有关)   
Language                        : 语言类型    (C、OC、Swift) 
</code></pre>

<h3 id="toc_2">代码</h3>

<pre><code>// C语言程序是由很多&quot;程序段&quot;组成       
#include&lt;stdio.h&gt;// 告诉系统printf函数在什么地方
int call() 
{

    return 0;

}

// command + b 将代码翻译为计算机能够识别的语言(0/1)
// command + r 在xcode中运行程序

int main()
{

    call(); // 调用函数

    // \n让输出的内容换行,固定格式

    printf(&quot;hello world&quot;);  // 调用系统函数

    return 0;

}

</code></pre>

<h3 id="toc_3">整个项目的细节</h3>

<pre><code>在左侧里面

有一个文件夹:Products 中 day01 是一个可执行文件 (默认时红色的)

需要通过代码 进行编译才能执行 (编译过后 变成了黑色)

可以通过show in finder (双击打开 是以终端打开)

会输出 hello worldlogout
</code></pre>

<h2 id="toc_4">练习</h2>

<h3 id="toc_5">项目的执行流程</h3>

<pre><code>1.编写代码

2.编译____生成.o 目标文件

3.链接____与系统的函数库进行连接

4.生成一个 可执行文件.out

5.运行
</code></pre>

<h3 id="toc_6">创建多个项目</h3>

<pre><code>1.点击 蓝色项目 

2.点击 同行的收缩按钮

3.在下面 点击加号 创建(TARGETS)即可
</code></pre>

<h3 id="toc_7">代码</h3>

<pre><code>#include &lt;stdio.h&gt;
int main() {

/*
printf(&quot; *** ***\n&quot;);
printf(&quot;*********\n&quot;);
printf(&quot; *******\n&quot;);
printf(&quot;  *****\n&quot;);
printf(&quot;   **\n&quot;);
 */
printf(&quot; *** ***\n*********\n *******\n  *****\n   **\n&quot;);

return 0;
}
</code></pre>

<h3 id="toc_8">运行其它的项目</h3>

<pre><code>1.在左上角的停止键 的旁边 进行选择
</code></pre>

<h2 id="toc_9">开发中应该注意的地方</h2>

<h3 id="toc_10">注意点</h3>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    // C语言每一条语句后面都必须有;号
    // C语言中除了&quot;&quot;引起来的地方,其它｀任何地方都不能出现中文
    // main函数的 return 0; 可以写, 也可以不写
    // main函数前面的int可以写,可以不写
    // main函数后面的()不可省略
    // 不要把main写错了
    // 同一程序中只能有一个main函数
    printf(&quot;lyh\n&quot;);
    return 0;
}

</code></pre>

<h3 id="toc_11">关键字</h3>

<pre><code> 1.关键字 都是小写
 2.有特殊的颜色
 3.C语言一共有32个关键字

————————————————————————————————————————————————————————————————————————————————————————-———————————————————————————————
    
#    &lt;数据类型 关键字&gt;
 
#    1.基本数据类型(5个)
    void    : 声明函数 无返回值 或 无参数, 声明无类型
    char    : 字符型类型数据, 属性整形数据的一种
    int     : 整型数据, 通常为编译器指定的机器字
    float   : 单精度浮点型数据, 属性浮点数据的一种
    double  : 双精度浮点型数据, 数据浮点数据
 
#    2.类型修饰  关键字(4个)
    short   : 修饰int, 短整型数据,可省略被修饰的
    long    : 修饰int, 长整型数据,可省略被修饰的
    signed  : 修饰整型数据, 有符号数据类型
    unsigned: 修饰整型数据, 无符号数据类型
 
#    3.复杂类型  关键字(5个)
    struct  : 结构体 声明
    union   : 共用体 声明
    enum    : 枚举   声明
    typedef : 声明类型别名
    sizepf  : 得到特定类型 或 特定类型变量的大小
 
#    4.存储级别关键字(6个)
    auto    : 指定为自动变量,由编译器自动分配
    static  : 指定为静态变量,分配在静态变量区
    register: 指定为寄存器变量,建议编译器将通过寄存器而不是堆栈传递数据
    extern  : 指定对应变量为外部变量,即标示变函数时在其它模块中寻找其定义
    const   : 与volatile合称&quot;cv特性&quot;,指定变量不改变
    volatile: 与const合称&quot;cv特性&quot;,指定变量的内存中取得该变量的值
 
 ————————————————————————————————————————————————————————————————————————————————————————-———————————————————————————————
    
#    &lt;数据类型 关键字&gt;
 
#    1.跳转结构(4个)
    return  : 用户函数体中, 返回特定值(或者是)
    continue: 结束当前循环, 开始下一轮循环
    break   : 跳出当前循环或 switch结构
    goto    : 无条件跳转语句
 
#    2.分支结构(5个)
    if      : 条件语句,后面不需要放分号
    else    : 条件语句 否定分支(与if连用)
    switch  : 开关语句(多重分支语句)
    case    : 开关语句中的分支标记
    default : 开关语句中的&quot;其它&quot;分支,可选
 
#    3.循环结构(3个)
    for     : for循环结构,for(1;2;3)4;的执行顺序为程序中,表达式1只计算一次，表达式2和表达式 执行页可以能一次都不执行
    do      : do循环结构, do 1 while(2);的执行顺序
    while   : while循环结构, while(1)2;的执行顺序
             表达式为真,则继续循环, 为假则跳出循环

————————————————————————————————————————————————————————————————————————————————————————-———————————————————————————————


#include &lt;stdio.h&gt;

int main() {
    // insert code here...
    printf(&quot;Hello, World!\n&quot;);
    return 0;
}
</code></pre>

<h3 id="toc_12">标识符</h3>

<pre><code>1. &#39;标识符&#39; 就是程序员自己在程序中起的一些名字
2. &#39;不能&#39; 与关键字名字 &#39;相同&#39;
3. 标识符的作用: 用来区分我们的函数和名字
4. 标识符的命名规则:
    # 1. 只能由26个英文字母的大小写、10个阿拉伯数字0-9、下划线_组成 
    # 2. 严格区分大小写，比如test和Test是2个不同的标识符
    # 3. 不能以数字开头
    # 4. 不可以使用关键字作为标识符
</code></pre>

<pre><code>#include &lt;stdio.h&gt;

int text()
{
    return 0;
}

int Text()
{
    return 0;
}

int main() {
    // insert code here...
    printf(&quot;Hello, World!\n&quot;);
    return 0;
}
</code></pre>

<h3 id="toc_13">标识符的命名规范 (可以遵守\可以不遵守)</h3>

<pre><code>命名规范
 1. 起一个有意义名字，能够提高代码的可读性
 2. 驼峰命名(除了第一个单词后面每个单词首字母大写) 如 sendMessage
 3. 下划线 如: send_message
</code></pre>

<pre><code>#include &lt;stdio.h&gt;

int sendMessage()   // 驼峰
{
   return 0;
}

int send_message()  // 下划线
{
   return 0;
}

int faxinxi()       // 拼音
{
   return 0;
}

int faMessage()     // 拼音+英文
{
   return 0;
}

int dasdhasdjkh()   // 大牛
{
   return 0;
}

int main() {
   // insert code here...
   printf(&quot;Hello, World!\n&quot;);
   return 0;
}
</code></pre>

<h3 id="toc_14">注释</h3>

<pre><code>// 注释是在所有计算机中都是非常重要的一个概念,从字面上看,就是注释,解释的意思

// 单行注释
// 单行注释 有自己的作用范围,范围就是从第二个斜线开始,一直到这一行的末尾
// 注释不会参与编译,也就是说注释不会被翻译为0和1

/*
多行注释
与/星 开头
以星/ 结尾
*/

// 多行注释有自己的作用范围,范围就是从/星开始,一直遇到第一个星/为止

# XCode 9 快捷键
# 在有 &#39;-(void)&#39; 方法的地方 option + command + /
</code></pre>

<pre><code>#include &lt;stdio.h&gt;

// 程序一启动就回自动调用名称叫main的函数

/*
 该方法用于根据一个电话号码发送一条信息
 其中num就是电话号码
 */

int sendMessageWithNumber (int num)
{
    return 0;
}

int main() {
    
    printf(&quot;11111!\n&quot;);
    printf(&quot;22222!\n&quot;);
    printf(&quot;33333!\n&quot;);
    printf(&quot;44444!\n&quot;);
    printf(&quot;55555!\n&quot;);
    return 0;
}
</code></pre>

<h3 id="toc_15">注释的注意点</h3>

<pre><code># 注释的注意点

/*
需要注释的内容
*/
————————————————————————————————————————

# 1.单行注释可以嵌套多行注释
/* 需要注释的内容 */
————————————————————————————————————————

# 2.单行注释潜逃多行注释的时候,多行注释必须在同一行内
/*
需要注释的内容
*/
————————————————————————————————————————

# 3.多行注释可以嵌套单行注释
/*
需要注释的内容
*/
————————————————————————————————————————

# 4.多行注释不能嵌套多行注释
/*
/*
需要注释的内容
*/
*/
————————————————————————————————————————

# 一般情况下,建议初学者,在刚开始学习编程的时候 先写注释再写代码
</code></pre>

<h2 id="toc_16">数据及数据类型</h2>

<h3 id="toc_17">数据</h3>

<pre><code># 数据类型
 {
 
    # 1.静态的数据
    :一般指的是永久性的数据,一般存储在硬盘中。
    (文档、照片、视频) 计算机重启，还会存储在磁盘上。
 
    # 2.动态的数据
    :动态数据指程序运行过程中, 动态产生的临时数据。一般存储在内存中。
    开启一个网页:输入一些搜索 比如:今天天气 其中今天天气就是 动态数据 重启电脑 动态数据就不在了
    
    # 3.静态跟动态的区别
    静态 存在 磁盘
    动态 存在 内存
    内存的 读写速度 远远大于 磁盘的 读写速度
 
    # 4. 静态数据 转成 动态数据
      比如: 播放视频 通过 播放器 播放 (静态数据 转成 动态数据)
 
    # 5. 动态数据 转成 静态数据
      比如:手机拍照 保存 到手机磁盘
 
    # 6. 数据的计量单位
    静态数据 占用 磁盘空间
    动态数据 占用 内存空间
    1 B     (Btye 字节)  = 8 bit(位)
    1 KB                = 1024 B
    1 MB                = 1024 KB
    1 GB                = 1024 MB
    1 TB                = 1024 GB
 }
 
# C语言数据类型概述
 {
 
  # C语言有4种数据类型
   # 1. 基本类型 
    [
        1.1 整型
            短整型 (short)
            整型   (int)
            长整型 (long)
 
        1.2 字符型
            char
 
        1.3 实型
            单精度 float
            双精度 double

    ]
   # 2. 构造类型
    [
        2.1 数组
        2.2 结构体
        2.3 枚举
        2.4 共用体
    ]
   # 3. 指针类型
 
   # 4. 空类型
        void
 }
</code></pre>

<h3 id="toc_18">常量</h3>

<pre><code>1. 整型常量
2. 实型常量
3. 字符常量
    {

    字符的特殊情况
    &#39;\n&#39;   换行,相当于敲一下回车。
    &#39;\t&#39;   跳到下一个tab位置,相当于按了一下键盘上的tab键。 
     \b    退格,相当于按了一下backspace
    &#39;\r&#39;   回车。
    &#39;\f&#39;   换页,光标移动到到下页开头。
    &#39;\\&#39;   输出\字符,也就是在屏幕上显示一个\字符。
    &#39;\&#39;&#39;   输出&#39;字符,也就是在屏幕上显示一个&#39;字符。
    &#39;\&quot;&#39;   输出&quot;字符,也就是在屏幕上显示一个&quot;字符。
    &#39;\ddd&#39; 1位到3位八进制数表示的字符。
    [
    如:\376, 则屏幕上显示一个黑块的方块。
    \xhh, 1位到2位十六进制数表示的字符。其中x不能丢了
    
    ]
 
    }
4. 字符串常量
5. 自定义常量
</code></pre>

<pre><code>#include &lt;stdio.h&gt;

int main() {
   
    // 整型常量
    10;
        
    // 实型常量(小数)
    // 单精度float ／ 双精度 double
    // 注意: 默认情况下 编写的小数 都是双精度
    10.1;// 双精度double
    88.8;// 双精度double
        
    5.2f; // 单精度float
        
    // 字符型常量,用单引号括起来的就是字符型常量
    // 注意:字符型常量的单引号只能写一个字符,如果写多个会报错
    &#39;a&#39;; // 字符型常量
    &#39;ab&#39;;// 错误
    &#39;1&#39;;
    &#39;12&#39;;// 错误, 12是由两个字符组成, 由1和2组成
    //    &#39;李&#39;;// 错误写法,因为一个汉字占3个字节
        
    // 字符型常量的特殊情况, 在C语言中,系统给某些字符的组合定义了特殊的函数,这些字符的组合可以当做单个字符来使用
    &#39;\n&#39;; // 回车 换行
        
    // 字符串型常量, 用双引号括起来的就是字符串型常量
    // 注意: 无论你用双引号扩起来了几个字符串,只要使用双引号括起来的都是字符串常量
    &quot;abc&quot;;
    &quot;a&quot;;
        
    // 自定义常量
    const int NUM = 998;
    return 0;
}
</code></pre>

<h3 id="toc_19">变量</h3>

<ul>
<li>1.什么是变量</li>
</ul>

<pre><code>表示的数据是可以经常修改的。当一个数据的值需要经常改变或者不确定时，就应该用变量表示。
</code></pre>

<ul>
<li>2.如何定义变量</li>
</ul>

<pre><code>定义变量（声明），任何变量在使用之前，必须先进行定义。

定义变量的目的：在内存中分配一块存储空间给变量，方便以后存储数据。

如果定义了多个变量，就会为这多个变量分别分配不同的存储空间。
</code></pre>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
// 1. 申请一块存储空间, 也就是定义一个变量
// 定义变量的格式: 数据类型 变量名称
// 定义一个基本数据类型的变量
// int float double char

int number; // 定义了一个名称叫做number的变量
// 会在内存中开辟一块存储空间给number, 用于存储数据

int value; // 定义了一个名称叫做value的变量
// 会在内存中开辟一块存储空间给value, 用于存储数据


return 0;
}
</code></pre>

<h3 id="toc_20">变量的初始化</h3>

<pre><code># 1.什么是变量

        表示的数据是可以经常修改的。当一个数据的值需要经常改变或者不确定时，就应该用变量表示。

# 2.如何定义变量
    
        定义变量（声明），任何变量在使用之前，必须先进行定义。
        定义变量的目的：在内存中分配一块存储空间给变量，方便以后存储数据。
        如果定义了多个变量，就会为这多个变量分别分配不同的存储空间。
</code></pre>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
/*
// 1. 申请一块存储空间, 也就是定义一个变量
// 定义变量的格式: 数据类型 变量名称
// 定义一个基本数据类型的变量
// int float double char

int number; // 定义了一个名称叫做number的变量
// 会在内存中开辟一块存储空间给number, 用于存储数据
int value; // 定义了一个名称叫做value的变量
// 会在内存中开辟一块存储空间给value, 用于存储数据
 */

/*
// 连续定义,如果多个变量都是相同类型的,那么可以采用连续定义
int number, value;

// 如何往变量对应的存储空间当中存储数据
// 注意: 变量中不能随便存储数据, 只能存储与之对应的数据
// 概念: 变量的第一次赋值, 我们称之为初始化, 注意, 要想使用变量都必须对变量进行初始化,然后才能够使用。
// 如果不对变量进行初始化, 那么其实变量中存储的是一些垃圾数据
number = 10; // 会将等号右边的数据放到数据放到等号左边的变量对应的存储空间中

// 如何使用变量
// 占位符号, %号是占位符号的启动起始符号

printf(&quot;%i\n&quot;,number);

float floatValue; // 定义了一个实型的变量
floatValue = 10.1f; // 往floatValue对应的存储空间中存储了10.1这个值
printf(&quot;%f\n&quot;,floatValue);
*/

// 初始化的两种方式
/*
// 1.先定义再初始化
int number;
number = 10;

// 2.定义的同时初始化
int value = 10;
*/

// 3.完全初始化
//    int number, value ;
//    number = value = 10;

int number;
number = 10;
int value;
value = number;

// 4.部分初始化
//    int number, value = 10;

return 0;
}
</code></pre>

<h3 id="toc_21">变量的作用域</h3>

<ul>
<li><p>本小节知识点:</p>

<ul>
<li><p>1.【掌握】变量的作用域</p></li>
<li><p>2.【掌握】局部变量</p></li>
<li><p>3.【掌握】全局变量</p></li>
<li><p>4.【掌握】常见错误</p></li>
</ul></li>
</ul>

<ol>
<li><p>变量的作用域</p>

<ul>
<li><p>C语言中所有变量都有自己的作用域，申明变量的类型不同，其作用域也不同。</p></li>
<li><p>C语言中的变量，按照作用域的范围可分两种，即局部变量和全局变量。</p></li>
</ul></li>
<li><p>局部变量</p>

<ul>
<li><p>局部变量也称之为内部变量。</p></li>
<li><p>局部变量是在函数内作定义说明的。</p></li>
<li><p>其作用域仅限于函数内(代码块)，离开该函数后再使用这种变量是非法的。</p></li>
</ul></li>
</ol>

<pre><code>#pragma mark 变量的作用域

/**
1. 什么是局部变量
定义在函数的都是局部变量
 
2. 什么是全局变量
定义在函数的外面
*/
    
#include &lt;stdio.h&gt;

int call()
{
    int number; // 定义变量
    return 0;
}
int value;  // 全局变量

int main()
{   
    
/*
//    number = 10;
int number; //变量有自己的作用域
// 变量的作用域 从定义的哪一行开始,一直到大括号结束或者遇到return为止
number = 10;
printf(&quot;%i\n&quot;, number);
return 0;   // 结束函数,只要执行到return 就 和执行到{}一样,代表着函数结束了
*/
    
//    call();
//    number = 50;

/*
{
int number;
}
number = 50;
*/
    
/*
int number;
{
// 自己没有 找爸爸
number = 10;
printf(&quot;%i\n&quot;, number);
}
*/
    
    int number;
    //    int number; 同意范围内不能出现同名的变量
    
{
// 1. 如果自己对应的范围中有，就使用自己的
// 2. 不同的范围可以有相同名称的变量
    int number;
    number = 10;
    printf(&quot;%i\n&quot;, number); // 10
}

    printf(&quot;%i\n&quot;, number); // 有可能输出0 有可能输出随机一个数
    return 0;
}
</code></pre>

<h3 id="toc_22">变量内存分析</h3>

<pre><code>1. 字节和地址
     内存就是字节，内存以“字节为单位”

2. 变量的存储 占据的存储空间
    一个变量所占用的存储空间，不仅跟变量类型有关，而且还跟编译器环境有关。同一种类型的变量，在不同编译器环境下所占用的存储空间又是不一样的
    * 所占用字节数跟类型有关，也跟编译器环境有关
    * 内存由大到下寻址
    * 变量存储单元的第一个字节的地址就是该变量的地址
    * 任何变量在内存中都是以二进制的形式存储。一个负数的二进制形式，其实就是对它的正数的二进制形式进行取反后再＋1（取反的意思就是0变1，1变0）
            编译器
    类型    16位  32位  64位(只关注64 因为是Mac都是64位的)
    char    1     1     1
    int     2     4     4
   float    4     4     4
  double    8     8     8
   short    2     2     2
    long    2     2     2
 long long  2     2     2
    void*   2     4     8
</code></pre>

<ul>
<li>代码</li>
</ul>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main()
{
    // 内存寻址从大到小 , 如果按照这种规则，那么先定义的变量内存地址一定大于后定义的变量
    /**
     *  比如当前地址有 0ffc1~0ffc16
     */
    int number = 0; // 0ffc13~0ff16
    int value = 0;  // 0ffc9~0ff12
    
    // 如何获得变量的详细地址(变量地址),&amp;变量名称
    //  利用%p展位符来打印变量的详细地址
    // 输出的是一个十六进制的数
    //      a/b/c/d/f/j
    //      10/11/12/13/14/15
            // 10/11/12/13/14/15
    printf(&quot;%p\n&quot;,&amp;number);// 先定义的 内存地址越大
    printf(&quot;%p\n&quot;,&amp;value);
    

    return 0;
}
</code></pre>

<h3 id="toc_23">printf 输出</h3>

<pre><code>printf 输出
 *  printf
 *  折叠代码快捷键  : command + option + 方向键
 *  单行注释的快捷键: command + /
 *  1. 指定位宽
 *  2. float 有效位只有7位 &lt;包含了整数部分&gt;
 *  3. double 有效位有15位 &lt;包含了整数部分&gt;
 *  4. 提升比格 输出的实型 类型 不确定  使用%.*f * 就是代表要输出的几个小数位
</code></pre>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  /*
  int number = 10;
  int value = 20;

  printf(&quot;%i,%i\n&quot;,number, value);

  float floatValue = 10.1f;
  printf(&quot;%f\n&quot;,floatValue);

  char charValue = &#39;a&#39;;
  printf(&quot;%c\n&quot;,charValue);

  double doubleValue = 9.9;
  printf(&quot;%lf&quot;,doubleValue);
  */

  /*
  // 1.指定位宽
  // 如何指定位宽? %mi; // 其中m就是位宽 而i输出对应类型的数据
  // 默认情况下位宽是右对齐,如果需要输出的类型宽度不够,会在左边补空格
  // 如果在位宽前面加上－号, 就会改变位宽的对齐方式为左对齐,如果需要输出的类型不够,会在右边补空格
  //    int number = 99;
  //    printf(&quot;%5i!!!\n&quot;,number);
  //    printf(&quot;%-5i!!!\n&quot;,number);

  //  注意: 如果制定了位宽,但是实际输出的内容超出了宽度,会按照实际的宽度来输出
  //    int number = 9999;
  //    printf(&quot;%2i\n&quot;,number);

  // 可以在位宽前面加上0,如果输入的内容不够就会用0来补,如果宽度已经够了, 那么会按照实际的宽度输出
  int number = 1;
  // 01
  // 2015-05-05
  printf(&quot;%02i\n&quot;,number);
   */

  /*
  // 2. 保留位数
  // %f 默认会保留6位小数
  // 指定保留多少位小数: %.nf , 其中n就是需要保留多少位小数,f用于输出实型
  float floatValue = 3.14;
  printf(&quot;%f&quot;,floatValue);
  */
  /*
  // 3. %f 各种坑
  // 为什么指定保留10位之后还不对呢 因为float类型有效位数是7位
  // 如何计算有效位? 从第一个开始计算
  // 如果输出的数据超出了有效位数,那么就会出现一些垃圾数据
  float floatValue = 3.1415966255f; // 3.141596 5557
  printf(&quot;%.10f\n&quot;,floatValue);    // 默认情况保留6位


  // 如果想完整的输出 那么必须将数据保存为double类型,因为都double类型的有效位是15位
  double doubleValue = 3.1415966255;
  printf(&quot;%.10lf\n&quot;,doubleValue);
   */

  // 如何提高比格
  float floatValue = 3.1415926;
  printf(&quot;%.*f\n&quot;,2,floatValue);
  printf(&quot;%.*f\n&quot;,5,floatValue);

  return 0;
}
</code></pre>

<h3 id="toc_24">scanf 输入 - 代码</h3>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    /*
    // 要求: 存储用户输入的整数
    // 1.用户输入的整数确定吗? 不确定
    // 2.如何接受用户输入的整数? scanf函数
    // scanf格式: scanf(&quot;格式化字符串&quot;,列表项); --&gt; scanf(&quot;%i&quot;, 变量);

    // 1.定义变量
    int number;
    // 2.利用scanf函数接受用户输入的数据
    scanf(&quot;%i&quot;,&amp;number);// 注意:必须告诉scanf函数变量的详细地址,才能存储用户输入的数据  // 如果您给一个房间,不给地址。他怎么知道这个房间在哪里
    // 3.输出接收到的数据
    printf(&quot;number = %i\n&quot;, number);
    */

    /*
    // 要求从控制台接收用户输入的两个整数,然后计算两个整数的和
    // 0.提示用户输入数据
    printf(&quot;亲,请输入第一个数字,已回车键结束\n&quot;);
    // 1.定义两个变量保存用户输入的数据
    int num1, num2;

    // 2.利用scanf接收用户输入的数据
    // 2.1 接收第一个数
    scanf(&quot;%i&quot;,&amp;num1);
    printf(&quot;亲,请输入第二个数字,已回车键结束\n&quot;);
    scanf(&quot;%i&quot;,&amp;num2);

    // 3.将接收到两个相加
    int result = num1 + num2;

    // 4.输入两个数验证结果
    printf(&quot;result = %d\n&quot;, result);
    */

    /*
    int num1, num2;
    num1 = num2 = 10;
    printf(&quot;num1 = %i, num2 =%i&quot;,num1,num2);
    */

    /*
    // 0.提示用户输入数据
    printf(&quot;亲,请输入两个数字,已回车键结束\n&quot;);
    // 1.定义两个变量保存用户输入的数据
    int num1, num2;
    // 2.利用scanf接收用户输入的数据
    // 注意: 利用scanf接收多个数据的时候,输入的内容要求和&quot;格式化字符串&quot;中的一模一样
    // 如果输入的数据与格式化字符串中的不匹配,那么scanf函数会自动终止
//    scanf(&quot;%i,%i&quot;,&amp;num1, &amp;num2);
    // 如果多个数据之间没有其他字符,那么可以利用 空格, 回车,table来作分隔
    // 但是,如果格式化字符串中有%c除外
//    scanf(&quot;%i%i&quot;,&amp;num1, &amp;num2);
    char charValue;
    // 输入 : 123-&gt;num1 a--&gt;charValue, 456--&gt;num2
    // 技巧 : 无论想接受什么类型的数据,只要有需要一次性接收多个,就给每一个数据之间加上固定的符号作为分隔符(例如:,)
    scanf(&quot;%i,%c,%i&quot;,&amp;num1,&amp;charValue,&amp;num2);


    // 3.将接收到的两个数相加
//    int result = (num1 + num2);
    // 4.输出两个数验证结果
//    printf(&quot;result = %d&quot;,result);

    printf(&quot;num1 = %i , char = %c, num2 = %i&quot;,num1,charValue,num2);
     */


    int number, number2;
    // \n 代表换行
    // 如何告诉scanf函数输入完毕？ 回车 == \n
    // 因为回车是scanf的结束符,所以不能scanf的格式化字符串末尾协商\n
    // 如果不小心把\n放到了scanf格式化字符串的末尾,也可以破,原样输入 或输入一个不匹配的
    scanf(&quot;%i\n%i\n&quot;,&amp;number,&amp;number2);
    printf(&quot;number = %i , number2 = %i\n&quot;,number, number2);


    return 0;
}
</code></pre>

<h3 id="toc_25">scanf函数的实现原理</h3>

<pre><code>快捷键
 添加断点: command +\
 
 利用scanf从输入缓存区中获取用户输入的数据
 
中只要类型不匹配,那么scanf函数的函数就会自动结束，并且不会修改对应的变量的值。也不会取走输入缓存区中保存
</code></pre>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    // 1. 提醒用户
//    printf(&quot;请输入两个整数,整数之间用逗号隔开,使用回车结束\n&quot;);
    // 2.定义变量保存用户输入的数据
    int num1, num2;

    char charValue;
    // 3.接收用户输入的数据
    // num1 = 123, charValue = + ,num2 = 456;

    scanf(&quot;%i%c%i&quot;,&amp;num1,&amp;charValue,&amp;num2);
    // 4.求差
//    int result = num1 - num2;
    // 5.输出验证
//    printf(&quot;result = %i\n&quot;,result);
    printf(&quot;num1 = %i, charVlaue = %c, num2 = %i&quot;,num1,charValue,num2);


    // 用户输入 --&gt; 输入缓存区 --&gt; scanf
    char charValue2;
    int num3;
    scanf(&quot;%c%i&quot;,&amp;charValue2 ,&amp;num3);
    printf(&quot;charValue2 = %c,num3 = %i&quot;,charValue2,num3);
    //
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-09-知识小集]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15181482163531.html"/>
    <updated>2018-02-09T11:50:16+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15181482163531.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;知识小集&quot;<br/>
date: 2018.02.09</p>

<h2 id="toc_0">tag: 生活总结</h2>

<h2 id="toc_1">几个好的但一直没有具体的实践的方法</h2>

<ul>
<li><p>番茄工作法</p></li>
<li><p>思维导图</p></li>
<li><p>时间管理</p></li>
<li><p>艾宾浩斯记忆法</p></li>
</ul>

<h2 id="toc_2">阅读感想 — 总结</h2>

<ol>
<li><p>工作上你会遇到各种问题，但是也会有各种办法解决，只不过是时间早晚问题</p></li>
<li><p>生活上你想学习更多的知识，不要去想一些多余的事，只要去看更多的书就行</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-06-上传壁纸功能（大佬版）]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15178861819686.html"/>
    <updated>2018-02-06T11:03:01+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15178861819686.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;上传壁纸功能（大佬版）&quot;<br/>
date: 2018.02.06</p>

<h2 id="toc_0">tag: iOS 总结</h2>

<h2 id="toc_1">上传壁纸</h2>

<ul>
<li>选中一个图片，并且发布</li>
</ul>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    self.title = @&quot;上传壁纸&quot;;
    // 点击UIButton AddWallpaper 是打开相册添加图片
    [_AddWallpaper addTarget:self action:@selector(AddWallpaperClick) forControlEvents:UIControlEventTouchUpInside];
    
    // 点击UIButton UpWallPaper 是上传图片
    [_UpWallpaper addTarget:self action:@selector(UpWallpaperClick) forControlEvents:UIControlEventTouchUpInside];
}

</code></pre>

<pre><code># pragma mark -- 添加壁纸
- (void)AddWallpaperClick {

    
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;请选择获取图片的位置&quot; preferredStyle:UIAlertControllerStyleAlert];
    UIAlertAction *setAlert = [UIAlertAction actionWithTitle:@&quot;拍照&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        [[QWImageTool sharedInstance] ShowTakePhotoWithController:self didFinishPicking:^(UIImage *image) {
            [self uploadImage:image];
            
        }];
    }];
    UIAlertAction *PhoneAlert = [UIAlertAction actionWithTitle:@&quot;从手机相册选择&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        //打开相册
        [[QWImageTool sharedInstance] ShowLocalPhotoWithController:self didFinishPicking:^(UIImage *image) {
            [self uploadImage:image];
            //            [self.headImageButton setImage:image forState:UIControlStateNormal];
            
        }
         ];
        
    }];
    UIAlertAction *hidAlert = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        
    }];
    [alert addAction:setAlert];
    [alert addAction:PhoneAlert];
    [alert addAction:hidAlert];
    
    [self presentViewController:alert animated:YES completion:^{
        
    }];
}
</code></pre>

<pre><code>- (void)UpWallpaperClick {

    [self uploadImageUrl:self.wallpaperUrl];
}

</code></pre>

<pre><code>
- (void)uploadImage:(UIImage *)image {

    NSMutableDictionary *param = [NSMutableDictionary dictionary];
    [param setValue:[QWAccountModel sharedModel].uid forKey:@&quot;uid&quot;];
    QWLog(@&quot;uid====%@&quot;,[QWAccountModel sharedModel].uid);
    MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];
    hud.label.text = @&quot;正在上传壁纸&quot;;
    [QWImageTool uploadWithImageArray:@[image] url:[QWHttpUrls uploadImageUrl] filename:@&quot;myfile.jpeg&quot; name:@&quot;myfile&quot; parameters:param  success:^(id  _Nullable json) {
        NSString *status = [NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;status&quot;]];
        QWLog(@&quot;json===%@&quot;,json);
        QWLog(@&quot;status===%@&quot;,status);
        if ([status isEqualToString:@&quot;1&quot;]) {
            NSString *iconPath = [NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;data&quot;]];
            _UpImage.image = image;
            [MBProgressHUD hideHUDForView:self.view animated:YES];
            [QWShowMessage showMessage:@&quot;上传壁纸成功&quot;];
            self.wallpaperUrl = iconPath;
//            [self uploadImageUrl:iconPath];
        }else{
            [MBProgressHUD hideHUDForView:self.view animated:YES];
            NSString *msg = [NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;msg&quot;]];
            if (![QWStringUtils isBlankString:msg]) {
                [QWShowMessage showMessage:msg];
            }else{
                [QWShowMessage showMessage:@&quot;上传壁纸失败&quot;];
            }
        }
    } failure:^(NSError * _Nullable error) {
        [MBProgressHUD hideHUDForView:self.view animated:YES];
        
        //[QWShowMessage showMessage:@&quot;网络异常&quot;];
    }];
    
}
- (void)uploadImageUrl:(NSString *)url{
    if ([WoWStringUtils isBlankString:url]) {
         [QWShowMessage showMessage:@&quot;上传壁纸失败&quot;];
        return;
    }
    NSMutableDictionary *param = [NSMutableDictionary dictionary];
    [param setValue:[QWAccountModel sharedModel].uid forKey:@&quot;uid&quot;];
    [param setValue:url forKey:@&quot;iconPath&quot;];
    [param setValue:@&quot;play&quot; forKey:@&quot;icon_title&quot;];//现在是默认参数，以后有需要修改
    [param setValue:@&quot;1&quot; forKey:@&quot;title_id&quot;];//现在是默认参数，以后有需要修改
    [QWHttpTool postmanager:[QWHttpUrls upPaperUrl] params:param success:^(id  _Nonnull manager, id  _Nonnull json) {
        
        NSString *status = [NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;status&quot;]];
        if ([status isEqualToString:@&quot;1&quot;]) {
            [MBProgressHUD hideHUDForView:self.view animated:YES];
            [QWShowMessage showMessage:@&quot;上传壁纸成功&quot;];
            self.wallpaperUrl = @&quot;&quot;;
            _UpImage.image = nil;
            
        }else{
            [MBProgressHUD hideHUDForView:self.view animated:YES];
            NSString *msg = [NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;msg&quot;]];
            if (![QWStringUtils isBlankString:msg]) {
                [QWShowMessage showMessage:msg];
            }else{
                [QWShowMessage showMessage:@&quot;上传壁纸失败&quot;];
            }
        }
    } failure:^(NSError * _Nonnull error) {
        [MBProgressHUD hideHUDForView:self.view animated:YES];
        [QWShowMessage showMessage:@&quot;网络异常&quot;];
    }];
    
}
</code></pre>

<ul>
<li>看完这种写法，我发现我前两篇文章写得真的是蠢。</li>
<li>项目里有这样的方法，我也尝试过，但是怎么就是写不出来，我想我还需要更加深造</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-05-生活总结]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15177929223553.html"/>
    <updated>2018-02-05T09:08:42+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15177929223553.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;工作、生活、爱情、婚姻&quot;<br/>
date: 2018.02.05<br/>
tag: 生活总结</p>

<hr/>

<h2 id="toc_0">近来工作</h2>

<ul>
<li><p>一个星期请了两次假，我从没有过的情况</p></li>
<li><p>万事，还是得以工作为主</p></li>
<li><p>把事情处理好了，你想怎么搞就这么搞，前提是，交给你的工作做完</p></li>
</ul>

<h2 id="toc_1">生活问题</h2>

<ul>
<li><p>家里淹水、朋友结婚、工作堆成山、巨额贷款</p></li>
<li><p>My concern is in the future, because i am going to spend the rest of my life there</p></li>
<li><p>Let go of the past, enjoy the present, embrace the future.</p></li>
<li><p>你的确也不是孩子了，你分得清主次分得清好坏分得清对错，也不会再像以前那样，能为了一个人，做出一些不符合常理的事</p></li>
<li><p>那个你，便是我。</p></li>
<li><p>我们都需要沉淀，都需要成长</p></li>
<li><p>别再因为一些不必要的事去请假，那样没意义</p></li>
<li><p>该健身的时候还是健身、该玩游戏的时候还是玩游戏、该工作的还是得工作，目标别停滞</p></li>
</ul>

<h3 id="toc_2">对于爱情的看法</h3>

<ul>
<li><p>物质基础</p></li>
<li><p>两情相愿</p></li>
<li><p>知根知底</p></li>
<li><p>三观、兴趣合</p></li>
<li><p>门当户对是有道理的</p></li>
</ul>

<h3 id="toc_3">对于婚姻的看法</h3>

<h4 id="toc_4">结婚和谈恋爱完全是两码事</h4>

<ul>
<li><p>那时候完完全全就是考验一个人的是否真的能担当起责任的时候</p></li>
<li><p>要考虑双方父母的感受</p></li>
<li><p>考虑能否养活一家人</p></li>
<li><p>如果有孩子了，是否能给与良好的教育等等一系列的问题</p></li>
<li><p>当然，问题远远不可能就这么点</p></li>
</ul>

<h4 id="toc_5">现实的问题</h4>

<ul>
<li><p>有钱有存款吗？</p></li>
<li><p>有房吗？</p></li>
<li><p>有车吗？</p></li>
<li><p>有公司吗？</p></li>
<li><p>有颜值吗？</p></li>
<li><p>潜力股吗？</p></li>
<li><p>你够成熟吗？</p></li>
<li><p>当然，也有一些那种不考虑这种因素的女孩子，也选择和你在一起</p></li>
<li><p>那恭喜你，你找到了爱情，记得珍惜</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-06-SVN 相关问题和登录密码问题]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15177928718830.html"/>
    <updated>2018-02-05T09:07:51+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15177928718830.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;SVN 相关问题和登录密码问题&quot;<br/>
date: 2018.02.06</p>

<h2 id="toc_0">tag: iOS 总结</h2>

<h2 id="toc_1">SVN 问题</h2>

<ul>
<li><p>开发项目的时候使用的是别人的包，所以在上传 SVN 的时候“鱿鱼” 操作不当导致两个项目混成一个项目，结果我很慌啊，灰常慌，灰常慌有木有啊，我了个..咳咳，正题</p></li>
<li><p>严重警告，不看后果自负：</p>

<ul>
<li>记得备份！！！</li>
<li>记得备份！！！</li>
<li>记得备份！！！</li>
</ul></li>
</ul>

<pre><code># 1. 打开 SVN 左边会有一栏你的项目，点击你所选的项目，右键 delete

# 2. 然后把项目的 APP ID 更改一下，因为是一款 APP 做成两种不同的效果，所以会有两个 APP ID

# 3. 继续打开项目所在的 SVN 路径下，拖入你正在开发的项目，上传 OK

# 4. emmm  暂时没发现什么问题，如果有问题加群联系：698453193



</code></pre>

<h2 id="toc_2">账号密码健壮性的问题</h2>

<ul>
<li>接口</li>
</ul>

<pre><code>//修改密码
+(NSString *)ChangeCodeUrlWithOp:(NSInteger)op{
    NSString *opStr =[NSString stringWithFormat:@&quot;%ld&quot;,op];
    NSMutableDictionary *dict = [[NSMutableDictionary alloc]initWithObjectsAndKeys:opStr,@&quot;op&quot;,
                                 nil];
    return [NSString stringWithFormat:@&quot;%@version=%@&amp;timeStamp=%@&amp;imei=%@&amp;tp=ucenter/updatepwd&amp;pt=2&amp;op=%ld&amp;sign=%@&quot;,QWUrl,QWVersion,[QWCommonFunc time],QWImei,op,[self getSignAndSignDict:dict]];

}
</code></pre>

<ul>
<li>这里的 op 后台传过来的是 int 类型，所以我们转换成 NSString 类型</li>
</ul>

<pre><code>-(void)buttonQuickRegister{
    NSString *phoneUrl = [NSString stringWithFormat:@&quot;%@&quot;,[QWHttpUrls phoneNumUrlWithphone:UserName.text]];
    [QWHttpTool get:phoneUrl params:nil success:^(id  _Nullable json) {
        
        M = [json[@&quot;status&quot;] intValue];
        QWLog(@&quot;msg==%@&quot;,json[@&quot;msg&quot;]);
        if ([UserName.text isEqualToString:@&quot;&quot;]) {
            [QWShowMessage showToastmsg:@&quot;手机号不能为空&quot;];
            return;
        }
        else if (![QWStringUtils checkTelNumber:UserName.text])
        {
            [QWShowMessage showToastmsg:@&quot;请输入正确的手机号&quot;];
            return;
        }else if (M == -1){
            [QWShowMessage showToastmsg:@&quot;该手机号不可用&quot;];
            
            return;
        }
        
        else if ([Password.text isEqualToString:@&quot;&quot;])
        {
            [QWShowMessage showToastmsg:@&quot;请输入密码&quot;];
            return;
        }else if (![QWStringUtils checkPassword:Password.text])
        {
            [QWShowMessage showToastmsg:@&quot;请设置6-18位数字和字母组合密码&quot;];
            return;
        }else if (![Password.text isEqualToString:Rpassword.text])
        {
            [QWShowMessage showToastmsg:@&quot;两次密码输入不一致&quot;];
            return;
        }
        else if ([code.text isEqualToString:@&quot;&quot;])
        {
            [QWShowMessage showToastmsg:@&quot;请输入验证码&quot;];
            return;
            
        }
        
        else
        {
            [code resignFirstResponder];
            [UserName resignFirstResponder];
            
            NSString *resUrl = [NSString stringWithFormat:@&quot;%@&quot;,[QWHttpUrls registerUrl]];
            QWLog(@&quot;resUrl====%@&quot;,resUrl);
            NSMutableDictionary *param = [[NSMutableDictionary alloc]init];
            [param setValue:UserName.text forKey:@&quot;account&quot;];
            [param setValue:Password.text forKey:@&quot;password&quot;];
            [param setValue:code.text forKey:@&quot;code&quot;];
            [QWHttpTool postmanager:resUrl params:param success:^(id  _Nonnull manager, id  _Nonnull json) {
                
                QWLog(@&quot;json====%@&quot;,json);
                QWLog(@&quot;status====%@&quot;,json[@&quot;status&quot;]);
                QWLog(@&quot;data====%@&quot;,json[@&quot;data&quot;]);
                
                if ([json[@&quot;status&quot;] intValue] == 1) {
                    //                QWAccountModel *model = [QWAccountModel sharedModel];
                    //                model.uid = json[@&quot;data&quot;][@&quot;uid&quot;];
                    //                model.nickname = json[@&quot;data&quot;][@&quot;username&quot;];
                    //                model.phone = json[@&quot;data&quot;][@&quot;phone&quot;];
                    //                model.isLogin = YES;
                    
                    [self.navigationController popViewControllerAnimated:YES];
                    
                }
                [QWShowMessage showToastmsg:json[@&quot;msg&quot;]];
                
            } failure:^(NSError * _Nonnull error) {
                
            }];
            
        }
    } failure:^(NSError * _Nonnull error) {
        
    }];



}
</code></pre>

<ul>
<li><p>看了以上大佬写的代码后，我发现我真的菜的扣 jio</p></li>
<li><p>开心一下：</p></li>
</ul>

<pre><code># 为什么图书管理不能穿拖鞋？

# 以防翻书舔手和看书抠脚丫的打起来
</code></pre>

<h2 id="toc_3">项目改名字</h2>

<ul>
<li>转：<a href="https://www.jianshu.com/p/2887d6fb5769">在iOS项目中，如何完美的修改项目名称</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我玩]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15175595412656.html"/>
    <updated>2018-02-02T16:19:01+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15175595412656.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">目前已完成</h1>

<ul>
<li>【我的收藏】添加收藏功能</li>
</ul>

<p><img src="media/15175595412656/15175597840530.jpg" alt=""/></p>

<ul>
<li><p>【我的收藏】里去掉【我的壁纸】<mark>解决</mark><br/>
<img src="media/15175595412656/15175599545819.jpg" alt=""/></p></li>
<li><p>【我的收藏】里重新写个收藏视频的 Cell <mark>解决</mark></p>

<ul>
<li>解决方法：把首页的整个搬到了【我的收藏】里</li>
</ul></li>
</ul>

<p><img src="media/15175595412656/15175599829171.jpg" alt=""/></p>

<hr/>

<h1 id="toc_1">目前未完成</h1>

<ul>
<li><p>首页的收藏 Cell 重用的问题 <mark>未解决</mark><br/>
<img src="media/15175595412656/15175597062702.jpg" alt=""/></p></li>
<li><p><mark>这里我只点击了这个兽人的名义的【收藏按钮】</mark><br/>
<img src="media/15175595412656/15175600541509.jpg" alt=""/></p></li>
<li><p><mark>就出现以下的情况 【天天打三国】的收藏按钮也被收藏了</mark><br/>
<img src="media/15175595412656/15175600967914.jpg" alt=""/></p></li>
</ul>

<hr/>

<ul>
<li><p>【我的壁纸】里上传图片功能实现 <mark>未解决</mark><br/>
<img src="media/15175595412656/15175602713974.jpg" alt=""/></p></li>
<li><p>壁纸这个板块可能还需要加个小版块，当时产品没想到，临时说的<br/>
<img src="media/15175595412656/15175626836279.jpg" alt=""/></p></li>
<li><p>点击上传不能将上图的图片上传至服务器，我这边的参数没来得及写<br/>
<img src="media/15175595412656/15175611925620.jpg" alt=""/></p></li>
</ul>

<pre><code># 大佬 麻烦了~

# 我回来请你吃饭，昂，顺便给你带点喜糖~

# 不是我结婚哈 朋友 朋友 ..

# 感谢了

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-02-上传壁纸功能]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15175348012289.html"/>
    <updated>2018-02-02T09:26:41+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15175348012289.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;上传壁纸功能&quot;<br/>
date: 2018.02.02<br/>
tag: iOS 总结</p>

<hr/>

<h1 id="toc_0">iOS 上传壁纸</h1>

<ul>
<li><p><a href="https://www.jianshu.com/p/850475044b40">iOS 图片上传看我就够了</a></p></li>
<li><p><a href="https://www.jianshu.com/p/5cce06c9f33c">iOS 上传图片和上传语音</a></p></li>
</ul>

<h1 id="toc_1">项目</h1>

<ul>
<li>在项目中我是使用第二篇稳重中的方法，但是具体我还没实现，需要请教大佬</li>
</ul>

<pre><code>@implementation WoWUpWallpaperViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.title = @&quot;上传壁纸&quot;;
    // 点击UIButton AddWallpaper 是打开相册添加图片
    [_AddWallpaper addTarget:self action:@selector(AddWallpaperClick) forControlEvents:UIControlEventTouchUpInside];
    
    // 点击UIButton UpWallPaper 是上传图片
    [_UpWallpaper addTarget:self action:@selector(UpWallpaperClick) forControlEvents:UIControlEventTouchUpInside];
}

# pragma mark -- 添加壁纸
- (void)AddWallpaperClick {
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:nil message:@&quot;请选择图片&quot; preferredStyle:UIAlertControllerStyleActionSheet];
    UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&quot;打开相册&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        [self openPhotoAlbum];
    }];
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil];
    [alertController addAction:OKAction];
    [alertController addAction:cancelAction];
    [self presentViewController:alertController animated:YES completion:nil];
}


- (void)UpWallpaperClick {
    QWLog(@&quot;   上传成功啦~~~~~~~ \n成功了？\n\t好像没有\n\t\t真的没有？\n\t\t\temmmmm。。。。   &quot;);
    [self postDataWithUrl:@&quot;http://www.qiangwan.com/index.php?tp=up&amp;op=image&quot; params:nil imageDatas:nil success:^(id response) {
        [QWShowMessage showToastmsg:@&quot;上传壁纸成功&quot;];
    } failure:^(NSError *error) {
        [QWShowMessage showToastmsg:@&quot;上传壁纸失败&quot;];
    }];
}

- (void)openPhotoAlbum {
    // 1.判断相册是否可以打开
    if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) return;
    // 2. 创建图片选择控制器
    UIImagePickerController *ipc = [[UIImagePickerController alloc] init];
    /**
     typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) {
     UIImagePickerControllerSourceTypePhotoLibrary, // 相册
     UIImagePickerControllerSourceTypeCamera, // 用相机拍摄获取
     UIImagePickerControllerSourceTypeSavedPhotosAlbum // 相簿
     }
     */
    // 3. 设置打开照片相册类型(显示所有相簿)
    ipc.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
    // ipc.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;
    // 照相机
    // ipc.sourceType = UIImagePickerControllerSourceTypeCamera;
    // 4.设置代理
    ipc.delegate = self;
    // 5.modal出这个控制器
    [self presentViewController:ipc animated:YES completion:nil];
}

#pragma mark -- &lt;UIImagePickerControllerDelegate&gt;--
// 获取图片后的操作
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info
{
    // 销毁控制器
    [picker dismissViewControllerAnimated:YES completion:nil];

    // 设置图片
    _UpImage.image = info[UIImagePickerControllerOriginalImage];
}



#pragma mark --- 上传图片
- (void)postDataWithUrl:(NSString *)url params:(NSMutableDictionary *)params imageDatas:(NSArray *)images success:(void (^)(id response))success failure:(void (^)(NSError *error))failure
{
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    manager.responseSerializer = [AFJSONResponseSerializer serializer];
    [manager.responseSerializer setAcceptableContentTypes:[NSSet　setWithObjects:@&quot;application/json&quot;,@&quot;text/html&quot;,@&quot;text/javascript&quot;,@&quot;text/xml&quot;,@&quot;text/plain&quot;,nil]];
    [manager POST:url parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) {
        for (UIImage *image in images) {
            // 图片太大会上传不到服务器上面去
            NSData *imageData = UIImageJPEGRepresentation(image, 0.1);;
            // 在网络开发中，上传文件时，是文件不允许被覆盖，文件重名
            // 要解决此问题，
            // 可以在上传时使用当前的系统事件作为文件名
            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
            // 设置时间格式
            formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;
            NSString *str = [formatter stringFromDate:[NSDate date]];
            NSString *fileName = [NSString stringWithFormat:@&quot;%@.png&quot;, str];
            /*
             此方法参数
             1. 要上传的[二进制数据]
             2. 对应网站上[upload.php中]处理文件的[字段&quot;file&quot;]
             3. 要保存在服务器上的[文件名]
             4. 上传文件的[mimeType]
             */
            NSUInteger index = [images indexOfObject:image];
            if (index == images.count-1) {
                // 上传位置图片data
                [formData appendPartWithFileData:imageData name:@&quot;posfile&quot; fileName:fileName mimeType:@&quot;image/png&quot;];
            } else {
                [formData appendPartWithFileData:imageData name:@&quot;file&quot; fileName:fileName mimeType:@&quot;image/png&quot;];
            }
        }
    } progress:^(NSProgress * _Nonnull uploadProgress) {
        NSLog(@&quot;uploadProgress = %@&quot;,uploadProgress);
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        success(responseObject);
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        failure(error);
    }];
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-02-02-工作清单]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15175344621527.html"/>
    <updated>2018-02-02T09:21:02+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15175344621527.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">工作清单</h2>

<ul>
<li>首页的收藏 Cell 重用的问题</li>
</ul>

<hr/>

<ul>
<li>【我的收藏】里去掉【我的壁纸】</li>
<li>【我的收藏】里重新写个收藏视频的 Cell</li>
</ul>

<hr/>

<ul>
<li>【我的壁纸】找找有没有更好上传图片的办法</li>
<li>【我的壁纸】里上传图片功能实现</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-01-31-获取本地图片]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15173609376252.html"/>
    <updated>2018-01-31T09:08:57+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15173609376252.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;获取本地图片&quot;<br/>
date: 2018.01.30<br/>
tag: iOS 总结</p>

<hr/>

<h2 id="toc_0">打开本地相册并添加到视图</h2>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    self.title = @&quot;上传壁纸&quot;;
    // 点击UIButton AddWallpaper 就是打开相册添加图片
    [_AddWallpaper addTarget:self action:@selector(AddWallpaperClick) forControlEvents:UIControlEventTouchUpInside];
    
    // 点击UIButton UpWallPaper 就是上传图片
    [_UpWallpaper addTarget:self action:@selector(UpWallpaperClick) forControlEvents:UIControlEventTouchUpInside];
}
</code></pre>

<pre><code>- (void)AddWallpaperClick {
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:nil message:@&quot;请选择图片&quot; preferredStyle:UIAlertControllerStyleActionSheet];
    
    UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&quot;打开相册&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        // 打开相册
        [self open];
    }];
    
    
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil];
    
    [alertController addAction:OKAction];
    [alertController addAction:cancelAction];
    
    [self presentViewController:alertController animated:YES completion:nil];
    
    
}
</code></pre>

<pre><code>- (void)open {
    // 1.判断相册是否可以打开
    if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) return;
    // 2. 创建图片选择控制器
    UIImagePickerController *ipc = [[UIImagePickerController alloc] init];
    /**
     typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) {
     UIImagePickerControllerSourceTypePhotoLibrary, // 相册
     UIImagePickerControllerSourceTypeCamera, // 用相机拍摄获取
     UIImagePickerControllerSourceTypeSavedPhotosAlbum // 相簿
     }
     */
    // 3. 设置打开照片相册类型(显示所有相簿)
    ipc.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
    // ipc.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;
    // 照相机
    // ipc.sourceType = UIImagePickerControllerSourceTypeCamera;
    // 4.设置代理
    ipc.delegate = self;
    // 5.modal出这个控制器
    [self presentViewController:ipc animated:YES completion:nil];
}
</code></pre>

<pre><code>#pragma mark -- &lt;UIImagePickerControllerDelegate&gt;--
// 获取图片后的操作
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info
{
    // 销毁控制器
    [picker dismissViewControllerAnimated:YES completion:nil];
    
    // 设置图片
    _UpImage.image = info[UIImagePickerControllerOriginalImage];
}

</code></pre>

<pre><code>- (void)UpWallpaperClick {
    
}
</code></pre>

<ul>
<li>这里是上传到后台数据，但是由于后台暂时没有给数据，就写成这样</li>
</ul>

<pre><code>+ (void)uploadImageWithImage:(UIImage *)image pid:(NSString *)pid success:(void (^)(id responseObject))success failureHandler:(void(^)(NSError *error)) failure{
    //加载提示菊花
    MBProgressHUD *hud;
    hud.label.text = NSLocalizedString(@&quot;加载中...&quot;, @&quot;HUD loading title&quot;);
    /*
     此段代码如果需要修改，可以调整的位置
     1. 把upload.php改成网站开发人员告知的地址
     2. 把file改成网站开发人员告知的字段名
     */
    
    //AFN3.0+基于封住HTPPSession的句柄x
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    
//    NSDictionary *dict = @{@&quot;username&quot;:@&quot;Saup&quot;};
    
    [manager POST:@&quot;&quot; parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) {
        NSData *data = UIImagePNGRepresentation(image);
        // 在网络开发中，上传文件时，是文件不允许被覆盖，文件重名
        // 要解决此问题，
        // 可以在上传时使用当前的系统事件作为文件名
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        // 设置时间格式
        formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;
        NSString *str = [formatter stringFromDate:[NSDate date]];
        NSString *fileName = [NSString stringWithFormat:@&quot;%@.png&quot;, str];
        
        //上传
        /*
         此方法参数
         1. 要上传的[二进制数据]
         2. 对应网站上[upload.php中]处理文件的[字段&quot;file&quot;]
         3. 要保存在服务器上的[文件名]
         4. 上传文件的[mimeType]
         */
       [formData appendPartWithFileData:data name:@&quot;file&quot; fileName:fileName mimeType:@&quot;image/png&quot;];
    
    } progress:^(NSProgress * _Nonnull uploadProgress) {

        //上传进度
        // @property int64_t totalUnitCount;     需要下载文件的总大小
        // @property int64_t completedUnitCount; 当前已经下载的大小
        //
        // 给Progress添加监听 KVO
        NSLog(@&quot;%f&quot;,1.0 * uploadProgress.completedUnitCount / uploadProgress.totalUnitCount);

    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        //上传成功时的回调
        [hud hideAnimated:YES];
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        //        //失败时的回调
        [hud hideAnimated:YES];
    }];
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-01-30-最近状态]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15172931924189.html"/>
    <updated>2018-01-30T14:19:52+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15172931924189.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;最近的状态&quot;<br/>
date: 2018.01.30</p>

<h2 id="toc_0">tag: 生活总结 </h2>

<h3 id="toc_1">关于工作</h3>

<ul>
<li>1. 在工作上不要拖后腿</li>
</ul>

<h3 id="toc_2">私人生活</h3>

<ol>
<li>冬天家里的水管爆了，三个房间全部被淹了</li>
<li>平板、手机、猫（wifi）全部报废</li>
<li> 在生活上不要生病</li>
<li> 学会好好照顾自己</li>
<li> 五年前的事过去了</li>
<li> 现在要学会生活</li>
<li> 学会坚持</li>
</ol>

<pre><code># 我很害怕给别人带来麻烦

# 我不想从别人口中得知自己不成熟、不够优秀、或者很烦和这种人做喷狗之类的话

# 我不愿意让自己变得一无是处，不喜欢自己被否定

# 所以，我只能默默的改变，如果现在给一些人带来了一些不必要的麻烦

# 请不要生气，我会改正的
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-01-30-收藏功能]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/2018-1-30-%E6%94%B6%E8%97%8F%E5%8A%9F%E8%83%BD.html"/>
    <updated>2018-01-30T10:50:41+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/2018-1-30-%E6%94%B6%E8%97%8F%E5%8A%9F%E8%83%BD.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;收藏功能&quot;<br/>
date: 2018.01.30<br/>
tag: iOS 总结</p>

<hr/>

<h3 id="toc_0">收藏</h3>

<ul>
<li> 项目要求要在首页的视频右下角添加一个收藏的功能</li>
<li>思路：

<ul>
<li>1. 进入一个界面先要进行判断是否有收藏，所以进行第一次网络请求</li>
<li>2. 判断成功后，在进行第二次事件，用户点击了收藏按钮所做的动作，例如收藏成功、取消收藏</li>
</ul></li>
</ul>

<pre><code>NSString *getiscollect = [QWHttpUrls getiscollectUrl];
NSMutableDictionary *params = [[NSMutableDictionary alloc]init];
[params setValue:[QWAccountModel sharedModel].uid forKey:@&quot;uid&quot;];
[params setValue:@&quot;3&quot; forKey:@&quot;collect_type&quot;];
[params setValue:self.gameID forKey:@&quot;collect_id&quot;];
[QWHttpTool postmanager:getiscollect params:params success:^(id  _Nonnull manager, id  _Nonnull json) {
    QWLog(@&quot;显示collectstatus===%@&quot;,json[@&quot;status&quot;]);
    QWLog(@&quot;显示collectURLdata===%@&quot;,json[@&quot;data&quot;]);
    if ([json[@&quot;status&quot;] isEqualToString:@&quot;1&quot;]) {
        [self.collectBtn setImage:[UIImage imageNamed:[NSString stringWithFormat:@&quot;已收藏&quot;]] forState:UIControlStateNormal];
//            Isselected = 2;
    }else{
        [self.collectBtn setImage:[UIImage imageNamed:[NSString stringWithFormat:@&quot;收藏&quot;]] forState:UIControlStateNormal];
//            Isselected = 1;
    }
} failure:^(NSError * _Nonnull error) {
    
}];
</code></pre>

<pre><code>- (void)btnClick{
    self.collectBtn.selected = !self.collectBtn.selected;
    
    if (Isselected==1) {
        if (self.collectBtn.selected) {
            NSString *collectURL = [QWHttpUrls CollectUrlWithOp:1 withcollect_type:3 Withcollect_id:_movieStr];
            NSMutableDictionary *params = [[NSMutableDictionary alloc]init];
            [params setValue:[QWAccountModel sharedModel].uid forKey:@&quot;uid&quot;];
            [QWHttpTool postmanager:collectURL params:params success:^(id  _Nonnull manager, id  _Nonnull json) {
                QWLog(@&quot;collect结果===%@&quot;,json[@&quot;msg&quot;]);
                [QWShowMessage showMessage:[NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;msg&quot;]]];
                [self.collectBtn setImage:[UIImage imageNamed:[NSString stringWithFormat:@&quot;已收藏&quot;]] forState:UIControlStateSelected];
            } failure:^(NSError * _Nonnull error) {
                
            }];
        }else{
            NSString *collectURL = [QWHttpUrls CollectUrlWithOp:2 withcollect_type:3 Withcollect_id:_movieStr];
            NSMutableDictionary *params = [[NSMutableDictionary alloc]init];
            [params setValue:[QWAccountModel sharedModel].uid forKey:@&quot;uid&quot;];
            [QWHttpTool postmanager:collectURL params:params success:^(id  _Nonnull manager, id  _Nonnull json) {
                QWLog(@&quot;collect结果===%@&quot;,json[@&quot;msg&quot;]);
                [QWShowMessage showMessage:[NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;msg&quot;]]];
                [self.collectBtn setImage:[UIImage imageNamed:[NSString stringWithFormat:@&quot;收藏&quot;]] forState:UIControlStateSelected];
            } failure:^(NSError * _Nonnull error) {
                
            }];
            
        }
        
    }else{
        if (self.collectBtn.selected) {
            
            NSString *collectURL = [QWHttpUrls CollectUrlWithOp:2 withcollect_type:3 Withcollect_id:_movieStr];
            NSMutableDictionary *params = [[NSMutableDictionary alloc]init];
            [params setValue:[QWAccountModel sharedModel].uid forKey:@&quot;uid&quot;];
            [QWHttpTool postmanager:collectURL params:params success:^(id  _Nonnull manager, id  _Nonnull json) {
                QWLog(@&quot;collect结果===%@&quot;,json[@&quot;msg&quot;]);
                [QWShowMessage showMessage:[NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;msg&quot;]]];
                [self.collectBtn setImage:[UIImage imageNamed:[NSString stringWithFormat:@&quot;收藏&quot;]] forState:UIControlStateSelected];
            } failure:^(NSError * _Nonnull error) {
                
            }];
        }else{
            NSString *collectURL = [QWHttpUrls CollectUrlWithOp:1 withcollect_type:3 Withcollect_id:_movieStr];
            NSMutableDictionary *params = [[NSMutableDictionary alloc]init];
            [params setValue:[QWAccountModel sharedModel].uid forKey:@&quot;uid&quot;];
            [QWHttpTool postmanager:collectURL params:params success:^(id  _Nonnull manager, id  _Nonnull json) {
                QWLog(@&quot;collect结果===%@&quot;,json[@&quot;msg&quot;]);
                [QWShowMessage showMessage:[NSString stringWithFormat:@&quot;%@&quot;,json[@&quot;msg&quot;]]];
                [self.collectBtn setImage:[UIImage imageNamed:[NSString stringWithFormat:@&quot;已收藏&quot;]] forState:UIControlStateSelected];
            } failure:^(NSError * _Nonnull error) {
                
            }];
            
        }
        
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-01-25-低级错误]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15168455023717.html"/>
    <updated>2018-01-25T09:58:22+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15168455023717.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;低级错误&quot;<br/>
date: 2018.01.25</p>

<h2 id="toc_0">tag: iOS 总结</h2>

<h3 id="toc_1">在 ContenView 上添加 button 不显示</h3>

<pre><code>    self.collectBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    self.collectBtn.frame = CGRectMake(screen_width-(screen_width-40), CGRectGetMaxY(_videoImage.frame)+left, 40, 40);
//    self.collectBtn.backgroundColor = [UIColor redColor];
    [self.collectBtn setBackgroundImage:[UIImage imageNamed:@&quot;star-highlighted&quot;] forState:UIControlStateNormal];
    [self.collectBtn setBackgroundImage:[UIImage imageNamed:@&quot;star-highlighted-template&quot;] forState:UIControlStateHighlighted];
    [self.collectBtn addTarget:self action:@selector(collectBtnClick) forControlEvents:UIControlEventTouchUpInside];
    
    [self.contentView addSubview:self.collectBtn];
</code></pre>

<p>这里的美工给的图片不是我之前的公司的美工，他们的命名方式很奇怪</p>

<ul>
<li>默认的格式：star-template</li>
<li>高亮的格式：star-highlighted-template</li>
</ul>

<p>一般的美工都是这么明名的</p>

<ul>
<li>默认的格式：star-template</li>
<li>高亮的格式：star-template-highlighted</li>
</ul>

<p>再加上我最近状态不佳，就直接写成以上的样子，最后什么都没显示</p>

<pre><code>总结：不管是在哪上班摸清楚他们的行为方式
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-01-22 Jeklly 搭建博客]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15167558151468.html"/>
    <updated>2018-01-24T09:03:35+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15167558151468.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;jeklly 搭建博客&quot;<br/>
date: 2018.01.22</p>

<h2 id="toc_0">tag: jeklly</h2>

<h3 id="toc_1">介绍</h3>

<ul>
<li><p>Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown （或者 Textile） 以及 Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的</p></li>
<li><p>使用 Jekyll 搭建博客之前要确认下本机环境，Git 环境（用于部署到远端）、Ruby 环境（Jekyll 是基于 Ruby 开发的）、包管理器 RubyGems </p></li>
<li><p>如果你是 Mac 用户，你就需要安装 Xcode。</p></li>
<li><p>Jekyll 是一个免费的简单静态网页生成工具，可以配合第三方服务例如： Disqus（评论）、多说(评论) 以及分享 等等扩展功能，Jekyll 可以直接部署在 Github（国外） 或 Coding（国内） 上，可以绑定自己的域名。Jekyll中文文档、Jekyll英文文档、Jekyll主题列表。</p></li>
</ul>

<h4 id="toc_2">Jekyll 环境配置</h4>

<ul>
<li>安装 jekyll</li>
</ul>

<pre><code>$ gem install jekyll     
</code></pre>

<ul>
<li>创建博客</li>
</ul>

<pre><code>$ jekyll new myBlog    
</code></pre>

<ul>
<li>进入博客目录
<code>
$ cd myBlog  
</code></li>
<li>启动本地服务</li>
</ul>

<pre><code>$ jekyll serve
</code></pre>

<ul>
<li>在浏览器里输入： <a href="http://localhost:4000">http://localhost:4000</a>，就可以看到你的博客效果了。</li>
</ul>

<h4 id="toc_3">目录结构</h4>

<ul>
<li><p>Jekyll 的核心其实是一个文本转换引擎。它的概念其实就是： 你用你最喜欢的标记语言来写文章，可以是 Markdown，也可以是 Textile,或者就是简单的 HTML, 然后 Jekyll 就会帮你套入一个或一系列的布局中。在整个过程中你可以设置URL路径, 你的文本在布局中的显示样式等等。这些都可以通过纯文本编辑来实现，最终生成的静态页面就是你的成品了。</p></li>
<li><p>一个基本的 Jekyll 网站的目录结构一般是像这样的：</p></li>
</ul>

<pre><code>.
├── _config.yml
├── _includes
|   ├── footer.html
|   └── header.html
├── _layouts
|   ├── default.html
|   ├── post.html
|   └── page.html
├── _posts
|   └── 2016-10-08-welcome-to-jekyll.markdown
├── _sass
|   ├── _base.scss
|   ├── _layout.scss
|   └── _syntax-highlighting.scss
├── about.md
├── css
|   └── main.scss
├── feed.xml
└── index.html
</code></pre>

<ul>
<li><p>这些目录结构以及具体的作用可以参考 官网文档</p></li>
<li><p>进入 _config.yml 里面，修改成你想看到的信息，重新 jekyll server ，刷新浏览器就可以看到你刚刚修改的信息了。</p></li>
<li><p>到此，博客初步搭建算是完成了，</p></li>
</ul>

<h4 id="toc_4">博客部署到远端</h4>

<ul>
<li>我这里讲的是部署到 Github Page 创建一个 github 账号，然后创建一个跟你账户名一样的仓库，如我的 github 账户名叫 leopardpan，我的 github 仓库名就叫 leopardpan.github.io，创建好了之后，把刚才建立的 myBlog 项目 push 到 username.github.io仓库里去（username指的是你的github用户名），检查你远端仓库已经跟你本地 myBlog 同步了，然后你在浏览器里输入 username.github.io ，就可以访问你的博客了。</li>
</ul>

<pre><code>---
layout: post
title:  &quot;Welcome to Jekyll!&quot;
date:   2016-10-16 11:29:08 +0800
categories: jekyll update
---

正文...
</code></pre>

<pre><code>title: 显示的文章名， 如：title: 我的第一篇文章 

date: 显示的文章发布日期，如：date: 2016-10-16 

categories: tag标签的分类，如：categories: 随笔
</code></pre>

<ul>
<li>我写文章使用的是 Mweb 编辑器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018.01.23 - hexo 博客搭建]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15166763998887.html"/>
    <updated>2018-01-23T10:59:59+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15166763998887.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;hexo 搭建博客&quot;<br/>
date: 2018.01.23</p>

<h2 id="toc_0">tag: hexo</h2>

<h2 id="toc_1">支付问题</h2>

<ul>
<li>微信支付
<img src="media/15166763998887/15166764452163.jpg" alt=""/>
<img src="media/15166763998887/15166764644716.jpg" alt=""/></li>
</ul>

<!--- [iOS_抓娃娃SDK使用文档10.1](media/15166763998887/iOS_%E6%8A%93%E5%A8%83%E5%A8%83SDK%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A310.1.pdf)-->

<h2 id="toc_2">Hexo 搭建博客</h2>

<h3 id="toc_3">配置环境</h3>

<ul>
<li><p>安装 Node（<mark>必须</mark>）</p>

<ul>
<li><mark>作用</mark>：用来生成静态页面的 到 Node.js 官网下载相应平台的最新版本，一路安装即可。</li>
</ul></li>
<li><p>安装Git（<mark>必须</mark>）</p>

<ul>
<li><mark>作用</mark>：把本地的 hexo 内容提交到 github 上去. 安装 Xcode 就自带有 Git，我就不多说了。</li>
</ul></li>
<li><p>申请GitHub（<mark>必须</mark>）</p>

<ul>
<li><mark>作用</mark>：是用来做博客的远程创库、域名、服务器之类的，怎么与本地 hexo 建立连接等下讲。 github 账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。</li>
</ul></li>
</ul>

<h3 id="toc_4">正式安装HEXO　</h3>

<p>1 - Node 和 Git 都安装好后，可执行如下命令安装 hexo：</p>

<pre><code>$ sudo npm install -g hexo
</code></pre>

<p>2 - 初始化</p>

<ul>
<li>创建一个文件夹，如：Blog，cd 到 Blog 里执行 hexo init 的。命令：</li>
</ul>

<pre><code>hexo init
</code></pre>

<ul>
<li>好啦，至此，全部安装工作已经完成！</li>
</ul>

<p>3 - 生成静态页面</p>

<ul>
<li>继续再Blog目录下执行如下命令，生成静态页面</li>
</ul>

<pre><code>hexo generate （hexo g  也可以）   
</code></pre>

<p>4.本地启动</p>

<ul>
<li>启动本地服务，进行文章预览调试，命令：</li>
</ul>

<pre><code>hexo server   
</code></pre>

<ul>
<li>浏览器输入 <a href="http://localhost:4000">http://localhost:4000</a> 我不知道你们能不能，反正我不能，因为我还有环境没配置好</li>
</ul>

<p>vim _config.yml<br/>
翻到最下面，改成我这样子的，注意： : 后面要有空格</p>

<h2 id="toc_5">配置Github</h2>

<h3 id="toc_6">建立Repository</h3>

<ul>
<li>建立与你用户名对应的仓库，仓库名必须为<mark>【your_user_name.github.io】</mark>，固定写法 然后建立关联，我的Blog在本地/Users/Desktop/Blog，Blog是我之前建的东西也全在这里面，有：</li>
</ul>

<pre><code>Blog 
　｜ 
　｜－－ _config.yml 
　｜－－ node_modules 
　｜－－ public 
　｜－－ source 
　｜－－ db.json    
　｜－－ package.json 
　｜－－ scaffolds 
　｜－－ themes 
</code></pre>

<p>　　　　　　 　　　<br/>
- 现在我们需要 <mark>_config.yml</mark> 文件，来建立关联，命令：</p>

<pre><code>deploy:
  type: git
  repository: https://github.com/leopardpan/leopardpan.github.io.git
  branch: master
</code></pre>

<ul>
<li>执行如下命令才能使用git部署</li>
</ul>

<pre><code>npm install hexo-deployer-git --save
</code></pre>

<ul>
<li>网上会有很多说法，有的type是github, 还有repository 最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。 忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。 然后，执行配置命令：</li>
</ul>

<pre><code>hexo deploy
</code></pre>

<ul>
<li>然后再浏览器中输入 <mark>http://your_name.github.io/</mark> 就行了，我的 github 的账户叫 <mark>xiaoxinhai</mark> ,把这个改成你 github 的账户名就行了</li>
</ul>

<h3 id="toc_7">部署步骤</h3>

<ul>
<li>每次部署的步骤，可按以下三步来进行。</li>
</ul>

<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre>

<ul>
<li>一些常用命令：</li>
</ul>

<pre><code>hexo new &quot;postName&quot;         # 新建文章
hexo new page &quot;pageName&quot;    # 新建页面
hexo generate               # 生成静态页面至public目录
hexo server                 # 开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）
hexo deploy                 # 将.deploy目录部署到GitHub
hexo help                   # 查看帮助
hexo version                # 查看Hexo的版本
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018.01.22 - 工作总结]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15165828761245.html"/>
    <updated>2018-01-22T09:01:16+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15165828761245.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">adjust SDK 接入</h2>

<ul>
<li>接入 初始化</li>
<li>YourAppToken 是后台创建的 iOS 端只需要调用就行
<img src="media/15165828761245/15165881950052.jpg" alt=""/></li>
</ul>

<h2 id="toc_1">SDK 开发</h2>

<pre><code>在SDK开发中，一般会需要经过几个流程，

# 开发SDK
# 测试SDK
# 把SDK交付给使用人员

这些东西看似步骤多，过程繁琐，而且每修改一次SDK就需要重复一次上述的过程，增加了一些不必要的操作。

当然，如果我们在SDK设计之初就有一个好的项目架构，就可以极大简化开发流程，提高开发效率.
</code></pre>

<ul>
<li><p><a href="https://www.jianshu.com/p/edc679a893c9">转：一种比较实用的iOS SDK项目架构</a></p></li>
<li><p>开发 SDK</p>

<ul>
<li>一般都是 <mark>.a</mark> </li>
<li>有的需求打包成 <mark>framework</mark></li>
</ul></li>
</ul>

<p><img src="media/15165828761245/15165913153841.jpg" alt=""/></p>

<h2 id="toc_2">pushToViewControllerWhenClickPushMessageWith - 这个是极光推送的方法</h2>

<pre><code>#pragma mark -- 程序点击推送消息进入的方法
// iOS 10 Support
- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler {
    // Required
    NSDictionary * userInfo = response.notification.request.content.userInfo;
    if([response.notification.request.triggerisKindOfClass:[UNPushNotificationTriggerclass]]) {
        [JPUSHServicehandleRemoteNotification:userInfo];
        
         [selfpushToViewControllerWhenClickPushMessageWith:userInfo]; //跳转页面
    }
    completionHandler();  // 系统要求执行这个方法
}

#pragma mark -- 程序跳转方法
-(void)pushToViewControllerWhenClickPushMessageWith:(NSDictionary*)msgDic{
    
    //将字段存入本地，因为要在你要跳转的页面用它来判断
   NSUserDefaults*pushJudge = [NSUserDefaultsstandardUserDefaults];
  //  [pushJudge setObject:@&quot;push&quot;forKey:@&quot;push&quot;];
//判断后台传送的标示（用于跳转哪一个页面的判断）
    if ([[msgDicobjectForKey:@&quot;type&quot;]isEqualToString:@&quot;active&quot;]){
//得到根部控制器
        TabBarController *hxl=(TabBarController *)self.window.rootViewController;
//得到控制器中的导航栏
        UINavigationController *nav=hxl.selectedViewController;
//得到导航栏对应的控制器
        UIViewController  *controller=(UIViewController *)nav.visibleViewController;
//进行跳转页面
        TSProductDetailViewController *pro=[[TSProductDetailViewControlleralloc]init];
        
         pro.detailid=[[msgDicobjectForKey:@&quot;id&quot;]integerValue];        
        [controller.navigationControllerpushViewController:pro animated:YES];
      
    }elseif ([[msgDicobjectForKey:@&quot;type&quot;]isEqualToString:@&quot;dynamics&quot;]){
        TabBarController *hxl=(TabBarController *)self.window.rootViewController;
        hxl.selectedIndex=2;
    }
}

#pragma mark iOS 10 前台收到通知（远程推送和本地通知）
- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(NSInteger))completionHandler {
    NSDictionary * userInfo = notification.request.content.userInfo;
    if([notification.request.triggerisKindOfClass:[UNPushNotificationTriggerclass]]) {
        /// iOS10处理远程推送
        [JPUSHServicehandleRemoteNotification:userInfo];
        /// 前台收到推送的时候转成本地通知 ===========================
        [self popAlert:userInfo];
        
    }else{
        /// iOS10处理本地通知添加到通知栏 ==============================
        completionHandler(UNNotificationPresentationOptionBadge|UNNotificationPresentationOptionSound|UNNotificationPresentationOptionAlert);
        
        
    }
    // 需要执行这个方法，选择是否提醒用户，有Badge、Sound、Alert三种类型可以选择设置
}

//在前台的时候 我这里就直接弹出提示框
-(void)popAlert:(NSDictionary *)pushMessageDic{
    NSLog(@&quot;%@&quot;,pushMessageDic);
    NSString *title;
    if([[pushMessageDicobjectForKey:@&quot;type&quot;]isEqualToString:@&quot;active&quot;])
    {
     title=@&quot;您有新的活动推送&quot;;
        [JCAlertViewshowTwoButtonsWithTitle:titleMessage:             [[pushMessageDicobjectForKey:@&quot;aps&quot;]objectForKey:@&quot;alert&quot;]ButtonType:JCAlertViewButtonTypeCancelButtonTitle:@&quot;取消&quot;Click:^{
            
        } ButtonType:JCAlertViewButtonTypeDefaultButtonTitle:@&quot;查看&quot;Click:^{
            [selfpushToViewControllerWhenClickPushMessageWith:pushMessageDic];
            
        }];
    }elseif([[pushMessageDic objectForKey:@&quot;type&quot;]isEqualToString:@&quot;dynamics&quot;]){
        title=@&quot;您有新的评论消息&quot;;
        [JCAlertViewshowOneButtonWithTitle:titleMessage:[[pushMessageDicobjectForKey:@&quot;aps&quot;]objectForKey:@&quot;alert&quot;]ButtonType:JCAlertViewButtonTypeCancelButtonTitle:@&quot;取消&quot;Click:^{
            
        }];
      
    }
    
   
}


</code></pre>

<h2 id="toc_3">测试数据</h2>

<ul>
<li>后台给了个接口

<ul>
<li>传进 IDFA 用来收集用户注册激活数据</li>
</ul></li>
</ul>

<p>1- <img src="media/15165828761245/15166026740705.jpg" alt=""/><br/>
2 - <img src="media/15165828761245/15166027434820.jpg" alt=""/></p>

<p>3 - <img src="media/15165828761245/15166027084987.jpg" alt=""/></p>

<p>4 - <img src="media/15165828761245/15166024878785.jpg" alt=""/></p>

<h2 id="toc_4">架构</h2>

<ul>
<li><a href="http://keeganlee.me/post/architecture/20160303">转：APP架构经验总结</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018.01.22 - 努力就会更优秀]]></title>
    <link href="https://github.com/HearOtSea/HearOtSea.github.io.git/15165828492939.html"/>
    <updated>2018-01-22T09:00:49+08:00</updated>
    <id>https://github.com/HearOtSea/HearOtSea.github.io.git/15165828492939.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>layout: post<br/>
title: &quot;努力就会更优秀&quot;<br/>
date: 2018.1.22</p>

<h2 id="toc_0">tag: 生活总结 </h2>

<h2 id="toc_1">你越努力，就越能更快的撞见幸运</h2>

<ul>
<li>有时候不想做的事就不做，别强迫自己，也别不好意思拒绝</li>
</ul>

<h2 id="toc_2">不要因为任何一些事就忘了自己的目标也别再丢了自己</h2>

<ul>
<li>头脑时刻保持清醒</li>
</ul>

<h2 id="toc_3">关于工作上的总结可以先记录下来，等有空闲就详细且系统的学习</h2>

]]></content>
  </entry>
  
</feed>
